feature:
  branch: "090-dag-watch-logs"
  created: "2026-01-11"
  status: "Draft"
  input: |
    DAG Watch & Logs - Real-time monitoring of DAG runs with easy access to per-spec logs.
    Commands: dag watch [run-id], dag logs <run-id> <spec-id>, dag list (enhanced).
    Log files stored at .autospec/state/dag-runs/<run-id>/logs/<spec-id>.log with timestamps.
    Log management: 50MB max per spec (configurable), truncate oldest 20% when exceeded.
    Watch command: auto-refresh table (2s default), shows spec status/progress/duration.
    Logs command: tail -f style streaming with --no-follow option.
    Easy run-id access via latest shortcuts and human-readable run-id format.

user_stories:
  - id: "US-001"
    title: "Monitor active DAG run status"
    priority: "P1"
    as_a: "developer running multi-spec workflows"
    i_want: "to see a live-updating status table of all specs in a DAG run"
    so_that: "I can monitor progress without manually checking each spec"
    why_this_priority: "Core functionality - real-time visibility is the primary use case for this feature"
    independent_test: "Run a DAG with multiple specs, verify watch command displays all specs with correct status updates"
    acceptance_scenarios:
      - given: "a DAG run is in progress with 5 specs"
        when: "I run 'dag watch' without arguments"
        then: "I see a table showing the most recent active run with all specs, their status, progress, and duration"
      - given: "the watch table is displayed"
        when: "a spec's status changes from pending to running"
        then: "the table refreshes automatically within the configured interval and shows the updated status"
      - given: "the watch table is displayed"
        when: "I press 'q' or Ctrl+C"
        then: "the watch command exits cleanly"

  - id: "US-002"
    title: "View specific run by ID"
    priority: "P1"
    as_a: "developer with multiple DAG runs"
    i_want: "to watch a specific run by its ID"
    so_that: "I can monitor any run, not just the most recent one"
    why_this_priority: "Essential for managing concurrent or historical runs"
    independent_test: "Start two runs, verify watch with explicit run-id shows the correct run"
    acceptance_scenarios:
      - given: "multiple DAG runs exist (some completed, some running)"
        when: "I run 'dag watch dag-20260110-143022'"
        then: "I see the status table for that specific run, not the most recent"
      - given: "I specify a non-existent run-id"
        when: "I run 'dag watch invalid-run-id'"
        then: "I see a clear error message indicating the run was not found"

  - id: "US-003"
    title: "Stream spec logs in real-time"
    priority: "P1"
    as_a: "developer debugging a spec execution"
    i_want: "to stream the live log output of a specific spec"
    so_that: "I can see what the autospec subprocess is doing in real-time"
    why_this_priority: "Critical for debugging and understanding spec execution progress"
    independent_test: "Run a spec, use dag logs to stream output, verify lines appear as spec produces them"
    acceptance_scenarios:
      - given: "a spec is currently running within a DAG run"
        when: "I run 'dag logs dag-20260110-143022 051-retry-backoff'"
        then: "I see the log file path printed first, followed by streaming log lines as they are written"
      - given: "I am streaming logs"
        when: "the spec completes"
        then: "the streaming continues to show final output and then waits (tail -f behavior)"
      - given: "I am streaming logs"
        when: "I press Ctrl+C"
        then: "the streaming stops and the command exits cleanly"

  - id: "US-004"
    title: "View logs without streaming"
    priority: "P2"
    as_a: "developer reviewing completed spec output"
    i_want: "to dump the entire log file and exit immediately"
    so_that: "I can quickly review logs without waiting or manually pressing Ctrl+C"
    why_this_priority: "Useful but not blocking; developers can use standard tools as fallback"
    independent_test: "Complete a spec run, use dag logs --no-follow, verify full output displayed and command exits"
    acceptance_scenarios:
      - given: "a spec has completed with log output"
        when: "I run 'dag logs dag-20260110-143022 051-retry-backoff --no-follow'"
        then: "I see the full log content printed and the command exits immediately"

  - id: "US-005"
    title: "Use latest run shortcut"
    priority: "P2"
    as_a: "developer working on current DAG run"
    i_want: "shortcuts to access the most recent run without looking up the ID"
    so_that: "I can quickly access logs and status without extra steps"
    why_this_priority: "Convenience feature that improves workflow efficiency"
    independent_test: "Create multiple runs, verify --latest selects the most recent"
    acceptance_scenarios:
      - given: "multiple DAG runs exist"
        when: "I run 'dag logs --latest 051-retry-backoff'"
        then: "I see logs from the most recent run for that spec"
      - given: "no DAG runs exist"
        when: "I run 'dag watch' without arguments"
        then: "I see a helpful message indicating no active runs exist"

  - id: "US-006"
    title: "List all DAG runs"
    priority: "P1"
    as_a: "developer managing multiple DAG runs"
    i_want: "to see a list of all runs with their IDs, status, and timing"
    so_that: "I can find the run I want to monitor or review"
    why_this_priority: "Required for run-id discovery; foundational for other commands"
    independent_test: "Create multiple runs with different statuses, verify list shows all with correct metadata"
    acceptance_scenarios:
      - given: "I have completed, running, and failed DAG runs"
        when: "I run 'dag list'"
        then: "I see a table with run-id as the first column, plus status, spec counts, and relative timestamps"
      - given: "no DAG runs have been executed"
        when: "I run 'dag list'"
        then: "I see a message indicating no runs exist"

  - id: "US-007"
    title: "Automatic log size management"
    priority: "P2"
    as_a: "developer running long workflows"
    i_want: "log files to be automatically truncated when they exceed size limits"
    so_that: "disk space is not exhausted by verbose spec output"
    why_this_priority: "Important for reliability but has reasonable defaults that work for most cases"
    independent_test: "Generate log output exceeding the limit, verify truncation with marker"
    acceptance_scenarios:
      - given: "a spec is running and its log file reaches 50MB"
        when: "more output is written to the log"
        then: "the oldest 20% of the log is removed and a [TRUNCATED] marker is added"
      - given: "the log size limit is configured to 100MB via dag.max_log_size"
        when: "the log reaches 100MB"
        then: "truncation occurs at the configured limit"

requirements:
  functional:
    - id: "FR-001"
      description: "MUST implement 'dag watch [run-id]' command displaying live-updating status table"
      testable: true
      acceptance_criteria: "Command shows spec ID, status, progress, duration, last update columns with auto-refresh"

    - id: "FR-002"
      description: "MUST implement auto-refresh for watch command with configurable interval (default 2 seconds)"
      testable: true
      acceptance_criteria: "Table updates at specified interval; --interval flag changes refresh rate"

    - id: "FR-003"
      description: "MUST allow exiting watch command via 'q' key or Ctrl+C"
      testable: true
      acceptance_criteria: "Both exit methods work cleanly without leaving terminal in bad state"

    - id: "FR-004"
      description: "MUST implement 'dag logs <run-id> <spec-id>' command with tail -f style streaming"
      testable: true
      acceptance_criteria: "New log lines appear in real-time; command continues after file is written"

    - id: "FR-005"
      description: "MUST implement '--no-follow' flag for dag logs to dump content and exit"
      testable: true
      acceptance_criteria: "Full log content displayed immediately; command exits with status 0"

    - id: "FR-006"
      description: "MUST implement '--latest' flag for dag logs to use most recent run"
      testable: true
      acceptance_criteria: "Correctly identifies and uses the most recent run-id"

    - id: "FR-007"
      description: "MUST select most recent active run when 'dag watch' is called without arguments"
      testable: true
      acceptance_criteria: "Automatically selects running DAG; shows appropriate message if none active"

    - id: "FR-008"
      description: "MUST enhance 'dag list' to show run-ids prominently as first column"
      testable: true
      acceptance_criteria: "Output format: RUN-ID, STATUS, SPECS (completed/total), STARTED (relative time)"

    - id: "FR-009"
      description: "MUST store per-spec logs at .autospec/state/dag-runs/<run-id>/logs/<spec-id>.log"
      testable: true
      acceptance_criteria: "Log files created at correct path; contain stdout/stderr from subprocess"

    - id: "FR-010"
      description: "MUST prefix each log line with timestamp in [HH:MM:SS] format"
      testable: true
      acceptance_criteria: "All log lines have consistent timestamp prefix"

    - id: "FR-011"
      description: "MUST print log file path at start of 'dag logs' output"
      testable: true
      acceptance_criteria: "First line shows 'Log: <path>' for easy copy/paste access"

    - id: "FR-012"
      description: "MUST use human-readable run-id format: dag-YYYYMMDD-HHMMSS"
      testable: true
      acceptance_criteria: "All generated run-ids follow this timestamp format"

    - id: "FR-013"
      description: "MUST implement log truncation when file exceeds max_log_size (default 50MB)"
      testable: true
      acceptance_criteria: "Oldest 20% removed; [TRUNCATED] marker added; compatible with tail -f"

    - id: "FR-014"
      description: "MUST implement watch command in pure Go without shelling out to external 'watch' command"
      testable: true
      acceptance_criteria: "Works on macOS where 'watch' is not available by default"

    - id: "FR-015"
      description: "MUST provide clear error messages for invalid run-id or spec-id"
      testable: true
      acceptance_criteria: "Error message indicates what was not found and suggests valid alternatives"

    - id: "FR-016"
      description: "MUST support dag.max_log_size configuration option"
      testable: true
      acceptance_criteria: "Config value respected; documented in config reference"

    - id: "FR-017"
      description: "MUST keep function implementations under 40 lines"
      testable: true
      acceptance_criteria: "All functions pass length check during code review"

    - id: "FR-018"
      description: "MUST wrap all errors with context using fmt.Errorf with %w"
      testable: true
      acceptance_criteria: "No bare 'return err' statements in production code"

    - id: "FR-019"
      description: "MUST use map-based table tests for all test files"
      testable: true
      acceptance_criteria: "Tests use map[string]struct pattern with t.Run"

    - id: "FR-020"
      description: "MUST pass 'make test && make fmt && make lint && make build' with exit code 0"
      testable: true
      acceptance_criteria: "All quality gates pass in CI and locally"

  non_functional:
    - id: "NFR-001"
      category: "performance"
      description: "Watch table refresh SHOULD complete within 500ms"
      measurable_target: "Table update time < 500ms measured from refresh trigger to display complete"

    - id: "NFR-002"
      category: "usability"
      description: "Log streaming SHOULD have minimal latency from file write to display"
      measurable_target: "Log lines appear within 100ms of being written to file"

    - id: "NFR-003"
      category: "reliability"
      description: "Watch command SHOULD handle terminal resize gracefully"
      measurable_target: "Table reformats correctly on SIGWINCH without crash or corruption"

    - id: "NFR-004"
      category: "usability"
      description: "Commands SHOULD work consistently across macOS and Linux"
      measurable_target: "All features functional on both platforms without platform-specific code paths"

    - id: "NFR-005"
      category: "code_quality"
      description: "Functions MUST be under 40 lines"
      measurable_target: "No function exceeds 40 lines of code"

    - id: "NFR-006"
      category: "code_quality"
      description: "Errors MUST be wrapped with context"
      measurable_target: "All error returns use fmt.Errorf with context message and %w verb"

    - id: "NFR-007"
      category: "code_quality"
      description: "Tests MUST use map-based table pattern"
      measurable_target: "All test functions use map[string]struct with named test cases"

success_criteria:
  measurable_outcomes:
    - id: "SC-001"
      description: "Users can see real-time status of all specs in a DAG run from a single command"
      metric: "Time to view full DAG status"
      target: "Under 2 seconds from command execution"

    - id: "SC-002"
      description: "Users can stream live log output for any running spec"
      metric: "Latency from log write to display"
      target: "Under 100 milliseconds"

    - id: "SC-003"
      description: "Users can access any run without memorizing or copying run-ids"
      metric: "Commands to access latest run logs"
      target: "Single command with --latest flag"

    - id: "SC-004"
      description: "Disk space is protected from unbounded log growth"
      metric: "Maximum log file size per spec"
      target: "Enforced at configured limit (default 50MB)"

    - id: "SC-005"
      description: "Standard Unix tools can be used with log files"
      metric: "Compatibility with tail -f, grep, less"
      target: "100% compatible with standard file streaming tools"

    - id: "SC-006"
      description: "Commands work identically on macOS and Linux"
      metric: "Platform-specific test failures"
      target: "Zero platform-specific failures"

key_entities:
  - name: "DAG Run"
    description: "A single execution of a DAG workflow containing multiple specs"
    attributes:
      - "run-id (format: dag-YYYYMMDD-HHMMSS)"
      - "status (pending, running, completed, failed)"
      - "specs (list of spec executions)"
      - "started timestamp"
      - "completed timestamp"

  - name: "Spec Execution"
    description: "A single spec being executed within a DAG run"
    attributes:
      - "spec-id (branch name like 051-retry-backoff)"
      - "status (pending, running, completed, failed)"
      - "progress (current task / total tasks)"
      - "duration"
      - "last update timestamp"
      - "log file path"

  - name: "Log File"
    description: "Captured stdout/stderr from autospec subprocess for a spec"
    attributes:
      - "path (.autospec/state/dag-runs/<run-id>/logs/<spec-id>.log)"
      - "timestamped lines ([HH:MM:SS] prefix)"
      - "max size (configurable, default 50MB)"
      - "truncation marker ([TRUNCATED])"

edge_cases:
  - scenario: "No DAG runs exist when running dag watch or dag list"
    expected_behavior: "Display helpful message indicating no runs exist; suggest how to start one"

  - scenario: "Specified run-id does not exist"
    expected_behavior: "Clear error message with list of valid run-ids or suggestion to use dag list"

  - scenario: "Specified spec-id does not exist within a valid run"
    expected_behavior: "Error message listing valid spec-ids for that run"

  - scenario: "Log file does not exist yet (spec pending)"
    expected_behavior: "dag logs waits for file to appear or shows message that spec hasn't started"

  - scenario: "Run completes while watch is active"
    expected_behavior: "Watch continues showing final state; can exit normally"

  - scenario: "Log file is truncated while being tailed"
    expected_behavior: "Streaming continues from truncation point; [TRUNCATED] marker visible"

  - scenario: "Multiple runs started at same second"
    expected_behavior: "Run-id includes additional disambiguator or uses subsecond precision"

  - scenario: "Terminal window very narrow"
    expected_behavior: "Table columns truncate gracefully with ellipsis; no crash or garbled output"

  - scenario: "Watch running when terminal closes unexpectedly"
    expected_behavior: "Process terminates cleanly; no orphaned goroutines or file handles"

assumptions:
  - "DAG run state is already persisted by previous specs (Spec 2 - DAG Runner)"
  - "Log files are created by the spec execution subprocess (Spec 2)"
  - "The .autospec/state/dag-runs directory exists and is writable"
  - "Terminal supports ANSI escape codes for table formatting and cursor control"
  - "Users have read access to log files in the state directory"
  - "The dag list command already exists from Spec 2 and needs enhancement"
  - "Run-id format (dag-YYYYMMDD-HHMMSS) is already established"

constraints:
  - "Watch command must be implemented in pure Go (no external 'watch' binary)"
  - "Log files must remain compatible with standard Unix tools (tail, grep, less)"
  - "Append-only log writes during execution (no rotation that would break tail -f)"
  - "Must work on both macOS and Linux without platform-specific builds"
  - "Must integrate with existing CLI command structure (dag subcommand group)"

out_of_scope:
  - "TUI with split panes or multiple views (users should use multiple terminals)"
  - "Interleaved multi-spec streaming (one log stream at a time)"
  - "Log compression or archival (handled by dag cleanup)"
  - "Web-based dashboard or GUI"
  - "Log search or filtering within the CLI (users should use grep, etc.)"
  - "Notifications or alerts when specs complete"
  - "Historical log retention policies beyond cleanup command"
  - "Real-time log streaming over network to remote viewers"

_meta:
  version: "1.0.0"
  generator: "autospec"
  generator_version: "autospec 0.8.2"
  created: "2026-01-11T17:16:29Z"
  artifact_type: "spec"
