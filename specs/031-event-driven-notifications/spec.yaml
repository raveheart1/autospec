feature:
  branch: "031-event-driven-notifications"
  created: "2025-12-16"
  status: "Draft"
  input: "Implement event-driven notification architecture. See .dev/tasks/031-event-driven-notifications.md for full details."

user_stories:
  - id: "US-001"
    title: "Command lifecycle automation"
    priority: "P1"
    as_a: "CLI command developer"
    i_want: "to wrap command execution in a lifecycle manager that handles timing, events, and notifications automatically"
    so_that: "I can write commands without duplicating 8-10 lines of notification boilerplate"
    why_this_priority: "Core value proposition - eliminates ~100 lines of duplicated code across 11 commands"
    independent_test: "Create a test command that uses lifecycle.Run() and verify events are emitted without manual notification code"
    acceptance_scenarios:
      - given: "a CLI command using lifecycle.Run() wrapper"
        when: "the command executes successfully"
        then: "CommandStart and CommandComplete events are emitted with correct timing and success status"
      - given: "a CLI command using lifecycle.Run() wrapper"
        when: "the command fails with an error"
        then: "CommandComplete event is emitted with success=false and the error included"

  - id: "US-002"
    title: "Event subscription for notifications"
    priority: "P1"
    as_a: "notification system"
    i_want: "to subscribe to command lifecycle events via an event bus"
    so_that: "I receive events automatically without commands explicitly calling notification methods"
    why_this_priority: "Required for decoupling - enables the notification handler to work without commands knowing about it"
    independent_test: "Subscribe a mock handler to the event bus, publish an event, verify handler receives it"
    acceptance_scenarios:
      - given: "notification handler subscribed to EventCommandComplete"
        when: "a command completes and the event is published"
        then: "notification handler receives the event and triggers sound/visual notification"
      - given: "multiple subscribers registered for the same event type"
        when: "the event is published"
        then: "all subscribers receive the event"

  - id: "US-003"
    title: "Thread-safe event publishing"
    priority: "P1"
    as_a: "system architect"
    i_want: "the event bus to handle concurrent publish and subscribe operations safely"
    so_that: "the system remains stable under concurrent command execution"
    why_this_priority: "Essential for correctness - race conditions in event handling could cause crashes or data loss"
    independent_test: "Run concurrent goroutines publishing and subscribing, verify no race conditions with -race flag"
    note: "kelindar/event provides thread-safety guarantees; we verify via race detector tests"
    acceptance_scenarios:
      - given: "multiple goroutines publishing events simultaneously"
        when: "events are dispatched"
        then: "all events are delivered without data races or lost events"
      - given: "a subscriber being added while events are being published"
        when: "the subscription completes"
        then: "the new subscriber receives subsequent events without affecting in-flight deliveries"

  - id: "US-004"
    title: "Async event dispatch"
    priority: "P2"
    as_a: "CLI user"
    i_want: "event dispatch to not block command execution"
    so_that: "slow subscribers cannot delay command completion"
    why_this_priority: "Important for user experience but not core functionality - commands should not wait on notifications"
    independent_test: "Create a slow subscriber (100ms delay), verify command completes in under 10ms"
    note: "kelindar/event runs each subscriber in its own goroutine by default (async)"
    acceptance_scenarios:
      - given: "a subscriber that takes 500ms to process an event"
        when: "events.Publish() is called"
        then: "the call returns immediately without waiting for subscriber completion"
      - given: "a slow subscriber"
        when: "multiple events are published rapidly"
        then: "events queue in subscriber's goroutine; no events lost"

  - id: "US-005"
    title: "Migrate existing commands"
    priority: "P1"
    as_a: "CLI user"
    i_want: "all 11 workflow commands to use the new lifecycle wrapper"
    so_that: "notification behavior is consistent and the codebase is simplified"
    why_this_priority: "Required to achieve the full benefit of the refactor - partial migration would leave inconsistent behavior"
    independent_test: "Run each command and verify it still sends notifications on completion"
    acceptance_scenarios:
      - given: "the specify command using lifecycle.Run()"
        when: "the command completes"
        then: "notification is triggered via event subscription (not direct call)"
      - given: "all 11 commands migrated to lifecycle.Run()"
        when: "running regression test TestAllCommandsHaveNotificationSupport"
        then: "the test passes verifying lifecycle wrapper usage"

  - id: "US-006"
    title: "Executor stage events"
    priority: "P2"
    as_a: "workflow system"
    i_want: "the executor to emit stage events instead of calling notification handler directly"
    so_that: "stage completion is also decoupled and extensible"
    why_this_priority: "Important for consistency but secondary to command-level lifecycle"
    independent_test: "Execute a stage, verify EventStageComplete is published"
    acceptance_scenarios:
      - given: "executor completing a workflow stage"
        when: "the stage finishes successfully"
        then: "EventStageComplete event is published with stage name and success status"

requirements:
  functional:
    - id: "FR-001"
      description: "MUST add github.com/kelindar/event dependency and create internal/events package with event types"
      testable: true
      acceptance_criteria: "go.mod includes kelindar/event; package exports CommandCompleteEvent, StageCompleteEvent with Type() uint32 methods"
      reference: "docs/events.md#event-types"

    - id: "FR-002"
      description: "MUST create internal/events/bus.go with global Dispatcher and Subscribe/Publish helper functions"
      testable: true
      acceptance_criteria: "events.Subscribe() and events.Publish() wrap kelindar/event dispatcher; race detector passes"
      reference: "docs/events.md#global-dispatcher-default"

    - id: "FR-003"
      description: "MUST create internal/lifecycle package with Run() function that wraps command execution"
      testable: true
      acceptance_criteria: "Run() emits CommandCompleteEvent with name, success, duration, and error fields"
      reference: "docs/events.md#publishing-events"

    - id: "FR-004"
      description: "MUST support RunWithContext() for cancellation support"
      testable: true
      acceptance_criteria: "Cancelled context causes Run to return context.Canceled error and emit event with Success=false"

    - id: "FR-005"
      description: "MUST convert notification handler to event subscriber pattern"
      testable: true
      acceptance_criteria: "Handler.Subscribe() uses events.Subscribe() to register for CommandCompleteEvent and StageCompleteEvent"
      reference: "docs/events.md#subscribing-to-events"

    - id: "FR-006"
      description: "MUST migrate all 11 CLI commands to use lifecycle.Run()"
      testable: true
      acceptance_criteria: "All commands pass existing tests and no longer contain notification boilerplate"

    - id: "FR-007"
      description: "MUST update executor to emit stage events instead of direct notification calls"
      testable: true
      acceptance_criteria: "Executor publishes EventStageComplete; NotificationHandler field can be removed"

    - id: "FR-008"
      description: "MUST maintain backward compatibility during migration"
      testable: true
      acceptance_criteria: "Existing notification behavior unchanged from user perspective"

    - id: "FR-009"
      description: "MUST update TestAllCommandsHaveNotificationSupport to verify lifecycle usage"
      testable: true
      acceptance_criteria: "Regression test passes and verifies commands use lifecycle wrapper"

    - id: "FR-010"
      description: "MUST pass all quality gates: make test, make fmt, make lint, and make build"
      testable: true
      acceptance_criteria: "All commands exit 0; no test failures, format changes, lint errors, or build failures"

  non_functional:
    - id: "NFR-001"
      category: "performance"
      description: "Event dispatch MUST NOT add measurable latency to command execution"
      measurable_target: "events.Publish() returns in under 1ms (p99); kelindar/event provides zero allocations, 4-10x faster than channels"

    - id: "NFR-002"
      category: "reliability"
      description: "Subscriber failures MUST NOT crash the application or affect other subscribers"
      measurable_target: "Subscriber handlers must include defer/recover; panics logged but not propagated"
      reference: "docs/events.md#error-handling-in-subscribers"

    - id: "NFR-003"
      category: "code_quality"
      description: "All functions must be under 40 lines; extract helpers for complex logic"
      measurable_target: "No function exceeds 40 lines excluding comments"

    - id: "NFR-004"
      category: "code_quality"
      description: "All errors must be wrapped with context using fmt.Errorf(\"doing X: %w\", err)"
      measurable_target: "Zero bare 'return err' statements in new code"

    - id: "NFR-005"
      category: "code_quality"
      description: "Tests must use map-based table-driven pattern with t.Parallel()"
      measurable_target: "All new test functions use map[string]struct pattern and call t.Parallel()"

    - id: "NFR-006"
      category: "code_quality"
      description: "Accept interfaces, return concrete types"
      measurable_target: "Function signatures follow interface-in, concrete-out pattern where applicable"

    - id: "NFR-007"
      category: "maintainability"
      description: "Event types MUST be minimal and well-documented"
      measurable_target: "No more than 10 event types initially; each type has doc comment explaining when emitted"

    - id: "NFR-008"
      category: "scalability"
      description: "Event subscriber count MUST be bounded to prevent goroutine proliferation"
      measurable_target: "Maximum 10 concurrent event subscribers per event type; Subscribe() returns error if limit exceeded"

success_criteria:
  measurable_outcomes:
    - id: "SC-001"
      description: "Notification boilerplate eliminated from all CLI commands"
      metric: "Lines of duplicated code removed"
      target: "~100 lines removed; each command's RunE function reduced by 6-8 lines"

    - id: "SC-002"
      description: "All 11 workflow commands use lifecycle wrapper"
      metric: "Commands migrated"
      target: "11 of 11 commands using lifecycle.Run()"

    - id: "SC-003"
      description: "Event bus handles concurrent operations safely"
      metric: "Race detector findings"
      target: "Zero race conditions detected when running tests with -race flag"

    - id: "SC-004"
      description: "Notification behavior unchanged for users"
      metric: "User-visible behavior changes"
      target: "Zero changes to when/how notifications appear"

    - id: "SC-005"
      description: "All quality gates pass"
      metric: "CI pipeline status"
      target: "make test, make fmt, make lint, make build all exit 0"

key_entities:
  - name: "CommandCompleteEvent"
    description: "Emitted when a CLI command finishes execution (implements event.Event interface)"
    attributes:
      - "Name (string) - command name (e.g., 'specify', 'plan')"
      - "Success (bool) - whether command succeeded"
      - "Duration (time.Duration) - execution time"
      - "Error (error) - error if failed, nil otherwise"
      - "Type() uint32 - returns TypeCommandComplete constant"
    reference: "docs/events.md#core-events"

  - name: "StageCompleteEvent"
    description: "Emitted when a workflow stage finishes (implements event.Event interface)"
    attributes:
      - "Name (string) - stage name"
      - "Success (bool) - whether stage succeeded"
      - "Duration (time.Duration) - execution time"
      - "Type() uint32 - returns TypeStageComplete constant"
    reference: "docs/events.md#core-events"

  - name: "Event Type Constants"
    description: "uint32 constants for kelindar/event dispatcher routing"
    attributes:
      - "TypeCommandComplete - command finished"
      - "TypeStageComplete - workflow stage finished"

  - name: "Global Dispatcher"
    description: "kelindar/event.Dispatcher instance wrapped by internal/events package"
    attributes:
      - "events.Subscribe[T](handler) - registers typed handler, returns unsubscribe func"
      - "events.Publish[T](event) - emits event to all subscribers"
      - "Goroutine-per-subscriber for async dispatch"
      - "Thread-safe via kelindar/event internals"
    reference: "docs/events.md#global-dispatcher-default"

  - name: "Lifecycle Manager"
    description: "Wraps command execution with event emission"
    attributes:
      - "Run(name, fn) - executes fn and emits CommandCompleteEvent"
      - "RunWithContext(ctx, name, fn) - cancellation-aware wrapper"
      - "RunStage(name, fn) - stage-level wrapper emitting StageCompleteEvent"
    reference: "docs/events.md#publishing-events"

  - name: "Notification Subscriber"
    description: "Event-driven notification handler"
    attributes:
      - "Subscribe() func() - registers handlers, returns unsubscribe func"
      - "onCommandComplete(CommandCompleteEvent) - handles command events"
      - "onStageComplete(StageCompleteEvent) - handles stage events"
    reference: "docs/events.md#subscribing-to-events"

edge_cases:
  - scenario: "Subscriber panics during event handling"
    expected_behavior: "Panic is recovered by defer/recover in handler wrapper; error logged; other subscribers unaffected (each runs in separate goroutine)"

  - scenario: "Event published with no subscribers"
    expected_behavior: "No error; event is silently discarded by kelindar/event dispatcher"

  - scenario: "Subscriber added during event dispatch"
    expected_behavior: "New subscriber receives subsequent events; current dispatch unaffected (kelindar/event handles thread-safety)"

  - scenario: "Unsubscribe called during event processing"
    expected_behavior: "Unsubscribe returns; subscriber may finish processing current event but receives no more"

  - scenario: "Context cancelled during lifecycle.RunWithContext()"
    expected_behavior: "CommandCompleteEvent still emitted with Error=context.Canceled, Success=false"

  - scenario: "Multiple lifecycle.Run() calls nested"
    expected_behavior: "Each call emits its own CommandCompleteEvent; inner completes before outer"

  - scenario: "Global dispatcher nil check"
    expected_behavior: "events.Publish() is safe to call; if dispatcher somehow nil, function returns silently"

  - scenario: "events.Publish() called during process shutdown (SIGTERM)"
    expected_behavior: "Late publishes are silently ignored; no panic or error; subscribers may not receive events if already terminated"

assumptions:
  - "The existing notification handler (internal/notify) will remain as a subscriber rather than being deleted"
  - "A global event bus instance is acceptable for this use case (vs. dependency injection everywhere)"
  - "kelindar/event's goroutine-per-subscriber model provides sufficient async dispatch for notifications"
  - "Commands are executed sequentially per user session (no need for request-scoped event buses)"
  - "The 11 commands listed in the task document are the complete set requiring migration"
  - "kelindar/event is stable and maintained (MIT license, zero external dependencies)"

constraints:
  - "Must maintain backward compatibility - existing notification behavior unchanged from user perspective"
  - "Must use github.com/kelindar/event for event bus implementation (approved external dependency)"
  - "Must not break existing tests - all current tests must continue to pass"
  - "Must follow project coding standards (40-line functions, error wrapping, table-driven tests)"
  - "Must follow patterns documented in docs/events.md for consistency"

out_of_scope:
  - "Persistent event storage or replay"
  - "Remote event publishing (message queues, webhooks)"
  - "Event filtering or transformation middleware"
  - "Metrics, logging, or telemetry subscribers (future extensions)"
  - "Configuration UI for event subscriptions"
  - "Event schema versioning"
  - "Distributed event bus for multi-process scenarios"
  - "Custom kelindar/event dispatcher instances (using global only)"

references:
  - name: "Event System Documentation"
    path: "docs/events.md"
    description: "Comprehensive guide to autospec's event-driven architecture"
  - name: "kelindar/event Repository"
    url: "https://github.com/kelindar/event"
    description: "High-performance in-process event dispatcher (external dependency)"

_meta:
  version: "1.0.0"
  generator: "autospec"
  generator_version: "autospec dev"
  created: "2025-12-16T23:57:49Z"
  artifact_type: "spec"
