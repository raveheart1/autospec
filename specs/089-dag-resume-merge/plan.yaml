plan:
  branch: "089-dag-resume-merge"
  created: "2026-01-11"
  spec_path: "specs/089-dag-resume-merge/spec.yaml"

summary: |
  This plan implements DAG resume and merge functionality for autospec's multi-spec
  orchestration system. The implementation adds three core capabilities: (1) resuming
  interrupted or failed DAG runs from their last checkpoint, (2) merging completed specs
  to a target branch in dependency order with AI-assisted conflict resolution, and
  (3) cleaning up worktrees after successful merges.

  Key technical decisions include using heartbeat-based stale process detection rather
  than PID-based detection (since PIDs can be reused), implementing a per-spec lock file
  with 30-second heartbeat updates, and supporting both agent-based and manual conflict
  resolution modes. The merge process follows dependency ordering to ensure dependent
  specs merge after their dependencies, and includes a 3-attempt retry with agent mode
  before falling back to manual resolution.

technical_context:
  language: "Go"
  framework: "Cobra CLI"
  primary_dependencies:
    - name: "gopkg.in/yaml.v3"
      version: "v3"
      purpose: "YAML serialization for state and lock files"
    - name: "github.com/spf13/cobra"
      version: "v1.8+"
      purpose: "CLI command structure"
    - name: "github.com/google/uuid"
      version: "v1"
      purpose: "Unique run ID generation"
  storage: "YAML files in .autospec/state/dag-runs/"
  testing:
    framework: "Go testing + testify"
    approach: "Map-based table-driven tests with parallel execution"
  target_platform: "Linux, macOS, Windows"
  project_type: "cli"
  performance_goals: "Resume command loads state and begins execution within 2 seconds"
  constraints:
    - "Must use existing .autospec/state/ directory structure"
    - "Must integrate with existing worktree management (internal/worktree package)"
    - "Must use existing agent abstraction (internal/cliagent package) for spawning agents"
    - "Lock files must be cross-platform compatible"
    - "Merge operations use standard git merge (no rebase or squash)"
    - "Sequential merges only - no octopus merge strategy"
  scale_scope: "Typical DAG runs with 5-20 specs, each with potential merge conflicts"

constitution_check:
  constitution_path: ".autospec/memory/constitution.yaml"
  gates:
    - name: "Test-First Development (PRIN-001)"
      status: "PASS"
      notes: "All new code will have tests written before implementation using map-based table-driven patterns"
    - name: "Validation-First Workflow (PRIN-002)"
      status: "PASS"
      notes: "Run state validation occurs before resume; merge validation ensures dependencies merged first"
    - name: "Performance Standards (PRIN-003)"
      status: "PASS"
      notes: "Resume loads state in <2s per NFR-006; heartbeat updates are lightweight 30s file writes"
    - name: "Idempotency and Retry Logic (PRIN-004)"
      status: "PASS"
      notes: "Resume is idempotent (skips completed specs); merge can be continued/retried"
    - name: "Standardized Exit Codes (PRIN-005)"
      status: "PASS"
      notes: "Commands will use exit code 0 for success, 1 for retryable failures"
    - name: "YAML-First Artifacts (PRIN-006)"
      status: "PASS"
      notes: "Run state, lock files, and merge status all stored as YAML"
    - name: "Go Coding Standards (PRIN-011)"
      status: "PASS"
      notes: "Functions <40 lines, errors wrapped with context, map-based table tests"

research_findings:
  decisions:
    - topic: "Stale process detection method"
      decision: "Heartbeat-based detection with 30-second update interval and 2-minute staleness threshold"
      rationale: "PIDs can be reused by the OS after process termination; heartbeat timestamps provide reliable detection across platforms without race conditions"
      alternatives_considered:
        - "PID-based detection (current lock.go approach) - rejected due to PID reuse"
        - "File lock with flock/lockfile - rejected due to cross-platform complexity"
        - "Process table inspection - rejected due to platform-specific APIs"
    - topic: "Lock file granularity"
      decision: "Per-spec lock files at .autospec/state/dag-runs/<run-id>/<spec-id>.lock"
      rationale: "Enables individual spec staleness detection and allows parallel execution to resume specific specs"
      alternatives_considered:
        - "Single run-level lock file - rejected because it doesn't support per-spec detection"
        - "In-memory locks with IPC - rejected due to complexity and crash recovery issues"
    - topic: "Merge conflict resolution strategy"
      decision: "Agent-first with 3 retries, fallback to manual with copy-pastable context"
      rationale: "Maximizes automation while ensuring human oversight for complex conflicts; context block enables use of any AI assistant"
      alternatives_considered:
        - "Agent-only with no fallback - rejected because some conflicts require human judgment"
        - "Manual-only - rejected because it defeats the purpose of automation"
    - topic: "Merge order strategy"
      decision: "Dependency order using existing taskgraph topological sort"
      rationale: "Ensures each merge builds on previous merges correctly; prevents conflicts from out-of-order merges"
      alternatives_considered:
        - "Completion order - rejected because dependent changes may not apply cleanly"
        - "Alphabetical order - rejected because it ignores logical dependencies"

data_model:
  entities:
    - name: "SpecLock"
      description: "Per-spec lock file for heartbeat-based stale detection"
      fields:
        - name: "spec_id"
          type: "string"
          description: "Identifier of the locked spec"
          constraints: "Must match a valid spec ID in the DAG"
        - name: "run_id"
          type: "string"
          description: "Run that owns this lock"
          constraints: "Must match the parent run's ID"
        - name: "pid"
          type: "int"
          description: "Process ID (informational, not used for detection)"
          constraints: "Positive integer"
        - name: "started_at"
          type: "time.Time"
          description: "When spec execution began"
          constraints: "Must be in the past"
        - name: "heartbeat"
          type: "time.Time"
          description: "Last heartbeat timestamp (updated every 30s)"
          constraints: "Must be updated while spec is running"
      relationships:
        - target: "DAGRun"
          type: "many-to-one"
          description: "Each spec lock belongs to exactly one run"
    - name: "MergeState"
      description: "Tracks merge status for each spec in a run"
      fields:
        - name: "status"
          type: "MergeStatus"
          description: "Current merge status"
          constraints: "One of: pending, merged, merge_failed, skipped"
        - name: "merged_at"
          type: "*time.Time"
          description: "When the spec was merged"
          constraints: "Set when status becomes 'merged'"
        - name: "conflicts"
          type: "[]string"
          description: "List of files with merge conflicts"
          constraints: "Empty if no conflicts"
        - name: "resolution_method"
          type: "string"
          description: "How conflicts were resolved"
          constraints: "One of: agent, manual, skipped, none"
        - name: "error"
          type: "string"
          description: "Error message if merge failed"
          constraints: "Empty on success"
      relationships:
        - target: "SpecState"
          type: "one-to-one"
          description: "Each spec has one merge state"
    - name: "ConflictContext"
      description: "Information provided for conflict resolution"
      fields:
        - name: "file_path"
          type: "string"
          description: "Path to the conflicted file"
          constraints: "Relative to repository root"
        - name: "conflict_diff"
          type: "string"
          description: "The conflict markers and content"
          constraints: "Contains <<<<<<< ======= >>>>>>> markers"
        - name: "spec_id"
          type: "string"
          description: "ID of the spec being merged"
          constraints: "Valid spec ID"
        - name: "spec_name"
          type: "string"
          description: "Human-readable name from dag.yaml"
          constraints: "Non-empty"
        - name: "spec_description"
          type: "string"
          description: "Full description from dag.yaml"
          constraints: "Non-empty"
        - name: "source_branch"
          type: "string"
          description: "Branch being merged from"
          constraints: "Valid git branch name"
        - name: "target_branch"
          type: "string"
          description: "Branch being merged into"
          constraints: "Valid git branch name"
      relationships:
        - target: "MergeState"
          type: "many-to-one"
          description: "Multiple conflicts can exist for one merge"

api_contracts:
  endpoints: []

project_structure:
  documentation:
    - path: "docs/public/dag-resume-merge.md"
      description: "User-facing documentation for dag resume, merge, and cleanup commands"
  source_code:
    - path: "internal/dag/resume.go"
      description: "Resume execution logic - load state, detect stale, skip completed"
    - path: "internal/dag/merge.go"
      description: "Merge orchestration - dependency order, conflict handling, state updates"
    - path: "internal/dag/speclock.go"
      description: "Per-spec lock file management with heartbeat mechanism"
    - path: "internal/dag/conflict.go"
      description: "Conflict detection, context building, and resolution strategies"
    - path: "internal/dag/cleanup.go"
      description: "Worktree cleanup logic with safety checks"
    - path: "internal/cli/dag/resume.go"
      description: "CLI command: autospec dag resume <run-id>"
    - path: "internal/cli/dag/merge.go"
      description: "CLI command: autospec dag merge <run-id> [--branch] [--continue] [--skip-failed]"
    - path: "internal/cli/dag/cleanup.go"
      description: "CLI command: autospec dag cleanup <run-id> [--force] [--all]"
    - path: "internal/dag/types.go"
      description: "Extended with ExecutionConfig.BaseBranch and MergeState types"
    - path: "internal/dag/runstate.go"
      description: "Extended SpecState with MergeStatus field"
  tests:
    - path: "internal/dag/resume_test.go"
      description: "Tests for resume logic including stale detection and skip behavior"
    - path: "internal/dag/merge_test.go"
      description: "Tests for merge ordering, conflict handling, and state updates"
    - path: "internal/dag/speclock_test.go"
      description: "Tests for heartbeat mechanism and staleness detection"
    - path: "internal/dag/conflict_test.go"
      description: "Tests for conflict context building and agent resolution"
    - path: "internal/dag/cleanup_test.go"
      description: "Tests for worktree cleanup with various safety conditions"

implementation_phases:
  - phase: 1
    name: "Core Data Structures & Spec Locking"
    goal: "Establish foundation with spec lock mechanism, extended types, and heartbeat system"
    deliverables:
      - "SpecLock struct with heartbeat field in internal/dag/speclock.go"
      - "Heartbeat update goroutine with 30-second interval"
      - "IsSpecLockStale() function with 2-minute threshold"
      - "Extended SpecState with MergeState field"
      - "ExecutionConfig.BaseBranch field for default merge target"
      - "Map-based table-driven tests for all new functions"
  - phase: 2
    name: "Resume Command Implementation"
    goal: "Enable resuming interrupted DAG runs from their last checkpoint"
    dependencies:
      - "Phase 1"
    deliverables:
      - "LoadAndValidateRun() for loading existing run state"
      - "DetectStaleSpecs() for marking interrupted specs"
      - "SkipCompletedSpecs() for filtering already-done specs"
      - "Resume() method on Executor with lock acquisition"
      - "CLI command: autospec dag resume <run-id>"
      - "Integration with existing parallel executor"
  - phase: 3
    name: "Merge Core Implementation"
    goal: "Implement dependency-ordered merge with state tracking"
    dependencies:
      - "Phase 1"
    deliverables:
      - "ComputeMergeOrder() using topological sort"
      - "MergeSpec() for single spec git merge"
      - "DetectConflicts() for identifying conflicted files"
      - "UpdateMergeState() for state persistence"
      - "CLI command: autospec dag merge <run-id> --branch <target>"
  - phase: 4
    name: "Conflict Resolution"
    goal: "Add agent-based and manual conflict resolution modes"
    dependencies:
      - "Phase 3"
    deliverables:
      - "BuildConflictContext() for generating resolution context"
      - "ResolveWithAgent() using cliagent.Execute()"
      - "OutputManualContext() for copy-pastable block"
      - "Retry logic with 3 attempts before fallback"
      - "CLI flags: --continue, --skip-failed"
  - phase: 5
    name: "Worktree Cleanup"
    goal: "Implement cleanup command with safety checks"
    dependencies:
      - "Phase 3"
    deliverables:
      - "CleanupRun() for removing merged spec worktrees"
      - "Safety checks for uncommitted changes and unpushed commits"
      - "CLI command: autospec dag cleanup <run-id> [--force] [--all]"
      - "Integration with dag merge --cleanup flag"
  - phase: 6
    name: "Integration & Polish"
    goal: "End-to-end testing, documentation, and quality gates"
    dependencies:
      - "Phase 2"
      - "Phase 4"
      - "Phase 5"
    deliverables:
      - "Integration tests for full resume → merge → cleanup workflow"
      - "User documentation in docs/public/dag-resume-merge.md"
      - "Edge case handling (all specs complete, corrupted state, etc.)"
      - "make test && make fmt && make lint && make build all pass"

open_questions:
  - question: "Should agent resolution validate the merged code compiles/passes tests?"
    context: "The spec mentions 'produces syntactically invalid code' as a failure case, but doesn't specify validation depth"
    proposed_resolution: "Start with syntax validation only (go build/compile check); defer test validation to future iteration as it adds significant complexity"
  - question: "How should concurrent dag merge commands be handled?"
    context: "Two users or processes might try to merge the same run simultaneously"
    proposed_resolution: "Use the existing run-level lock file to prevent concurrent merges; second merge attempt returns error with lock holder info"

_meta:
  version: "1.0.0"
  generator: "autospec"
  generator_version: "autospec 0.8.2"
  created: "2026-01-11T10:08:13Z"
  artifact_type: "plan"
