plan:
  branch: "087-dag-run-sequential"
  created: "2026-01-11"
  spec_path: "specs/087-dag-run-sequential/spec.yaml"

summary: |
  Implement the core DAG execution engine for sequential multi-spec orchestration.
  The implementation leverages the existing internal/dag parser and internal/worktree
  manager to create isolated worktrees on-demand for each spec (branch naming:
  dag/<run-id>/<spec-id>) and execute them in layer-dependency order. Key features:
  run locking to prevent concurrent DAG runs on overlapping specs, --dry-run mode
  to preview execution plan, configuration via .autospec/config.yml dag: and worktree:
  sections. State persistence follows the atomic write pattern established in
  retry/worktree packages, using YAML format stored in .autospec/state/dag-runs/<run-id>.yaml.
  Terminal output uses prefixed lines for spec identification, with complete logs
  captured to .autospec/state/dag-runs/<run-id>/logs/. On failure: stop execution,
  preserve worktree for debugging, output resume/retry instructions. This spec focuses
  on sequential execution only - parallel execution and resume capability are deferred
  to Specs 3 and 4.

technical_context:
  language: "Go"
  framework: "Cobra CLI"
  primary_dependencies:
    - name: "github.com/spf13/cobra"
      version: "v1.8.0"
      purpose: "CLI command framework"
    - name: "gopkg.in/yaml.v3"
      version: "v3.0.1"
      purpose: "YAML parsing and serialization for state files"
    - name: "github.com/fatih/color"
      version: "v1.18.0"
      purpose: "Colored terminal output for spec prefixes"
    - name: "github.com/google/uuid"
      version: "v1.6.0"
      purpose: "Generating unique run IDs"
  storage: "YAML files in .autospec/state/dag-runs/ (state files, lock files, logs)"
  testing:
    framework: "Go testing package"
    approach: "Unit tests with map-based table-driven patterns, mock interfaces for git/exec"
  target_platform: "Linux, macOS, Windows"
  project_type: "cli"
  performance_goals: "<1 second overhead per spec for orchestrator operations"
  constraints:
    - "Must reuse existing internal/dag parser"
    - "Must reuse existing worktree.Manager"
    - "No parallel execution in this spec"
    - "No resume capability in this spec"
    - "Functions under 40 lines"
  scale_scope: "DAGs with 10-50 specs across 3-5 layers"

constitution_check:
  constitution_path: ".autospec/memory/constitution.yaml"
  gates:
    - name: "Test-First Development (PRIN-001)"
      status: "PASS"
      notes: "Plan includes test tasks before implementation for each component"
    - name: "Validation-First Workflow (PRIN-002)"
      status: "PASS"
      notes: "State file updates validated before proceeding; DAG parsing uses existing validated parser"
    - name: "Performance Standards (PRIN-003)"
      status: "PASS"
      notes: "NFR-002 targets <1s overhead per spec; state operations designed for minimal latency"
    - name: "Idempotency and Retry Logic (PRIN-004)"
      status: "PASS"
      notes: "State persistence uses atomic write pattern (temp file + rename)"
    - name: "Standardized Exit Codes (PRIN-005)"
      status: "PASS"
      notes: "Exit 0 for success, 1 for execution failure, 3 for invalid arguments"
    - name: "YAML-First Artifacts (PRIN-006)"
      status: "PASS"
      notes: "Run state persisted as YAML in .autospec/state/dag-runs/"
    - name: "Code Formatting (PRIN-007)"
      status: "PASS"
      notes: "Final task requires make fmt && make lint to pass"
    - name: "Go Coding Standards (PRIN-011)"
      status: "PASS"
      notes: "NFRs include function length <40 lines, error wrapping, map-based table tests"
    - name: "Command Template Independence (PRIN-012)"
      status: "N/A"
      notes: "No command templates being modified"

research_findings:
  decisions:
    - topic: "Run ID generation strategy"
      decision: "Use timestamp prefix + 8-character UUID suffix"
      rationale: "Timestamp provides chronological sorting; UUID ensures uniqueness; compact format for directory naming"
      alternatives_considered:
        - "Pure UUID (too long, no chronological context)"
        - "Sequential integers (collision risk across machines)"
        - "Timestamp only (potential collision in same second)"
    - topic: "State file update strategy"
      decision: "Atomic write with temp file + rename pattern"
      rationale: "Consistent with retry.go and worktree state.go patterns; prevents corruption on crash"
      alternatives_considered:
        - "Direct file write (corruption risk)"
        - "SQLite database (overkill for this use case)"
    - topic: "Output prefixing strategy"
      decision: "Use io.Writer wrapper that prefixes each line with [spec-id]"
      rationale: "Clean separation of concerns; testable; reusable"
      alternatives_considered:
        - "String manipulation post-execution (memory intensive)"
        - "Per-character prefix detection (complex, slow)"
    - topic: "Layer execution strategy"
      decision: "Sequential within layer, sequential across layers"
      rationale: "Simplest implementation for Spec 2; parallel execution deferred to Spec 3"
      alternatives_considered:
        - "Parallel within layer (Spec 3 scope)"
    - topic: "Failure handling strategy"
      decision: "Mark failed spec, stop execution entirely, preserve worktree for debugging"
      rationale: "Safer default for sequential mode; user can explicitly resume/retry; worktree preserved for debugging"
      alternatives_considered:
        - "Continue remaining specs in layer (confusing if spec has side effects)"
        - "Fail fast and clean up worktrees (loses debugging context)"
    - topic: "Worktree creation strategy"
      decision: "On-demand creation with branch naming dag/<run-id>/<spec-id>"
      rationale: "Avoids disk exhaustion for large DAGs; unique branch names prevent collisions"
      alternatives_considered:
        - "Upfront creation (disk exhaustion risk)"
        - "Simple spec-id branch names (collision risk across runs)"
    - topic: "Run locking mechanism"
      decision: "Lock file at .autospec/state/dag-runs/<run-id>.lock with PID for stale detection"
      rationale: "Simple file-based locking; PID allows stale lock detection; per-spec granularity in lock file"
      alternatives_considered:
        - "Database-based locking (overkill)"
        - "No locking (race condition risk)"
    - topic: "Existing worktree handling"
      decision: "Skip if completed, prompt/force if failed/interrupted, never silently overwrite"
      rationale: "Safe defaults; respects previous work; explicit user action required for destructive operations"
      alternatives_considered:
        - "Always recreate (loses previous work)"
        - "Always reuse (may have corrupt state)"
    - topic: "Configuration structure"
      decision: "dag: and worktree: sections in .autospec/config.yml with hierarchical loading"
      rationale: "Consistent with existing config pattern; allows per-DAG overrides in dag.yaml execution section"
      alternatives_considered:
        - "Separate dag-config.yml file (fragmentation)"
        - "CLI flags only (not persistent)"

data_model:
  entities:
    - name: "DAGRun"
      description: "Represents a single execution of a DAG workflow"
      fields:
        - name: "run_id"
          type: "string"
          description: "Unique identifier for the run (timestamp_uuid format)"
          constraints: "Must be valid directory name"
        - name: "dag_file"
          type: "string"
          description: "Path to the dag.yaml being executed"
          constraints: "Must exist and be valid YAML"
        - name: "status"
          type: "string"
          description: "Overall run status"
          constraints: "One of: running, completed, failed, interrupted"
        - name: "started_at"
          type: "time.Time"
          description: "When the run began"
          constraints: "ISO 8601 format in YAML"
        - name: "completed_at"
          type: "*time.Time"
          description: "When the run finished (nil if still running)"
          constraints: "ISO 8601 format in YAML, nullable"
        - name: "specs"
          type: "map[string]*SpecState"
          description: "State of each spec in the DAG"
          constraints: "Keys are spec IDs from dag.yaml"
      relationships:
        - target: "SpecState"
          type: "one-to-many"
          description: "A run contains state for each spec in the DAG"

    - name: "SpecState"
      description: "Tracks the execution state of a single spec within a DAG run"
      fields:
        - name: "spec_id"
          type: "string"
          description: "Identifier from dag.yaml"
          constraints: "Must match feature.id in dag.yaml"
        - name: "layer_id"
          type: "string"
          description: "Layer this spec belongs to"
          constraints: "Must match layer.id in dag.yaml"
        - name: "status"
          type: "string"
          description: "Execution status"
          constraints: "One of: pending, running, completed, failed, blocked"
        - name: "worktree_path"
          type: "string"
          description: "Path to the worktree for this spec"
          constraints: "Absolute path, empty if not yet created"
        - name: "started_at"
          type: "*time.Time"
          description: "When spec execution began"
          constraints: "ISO 8601 format, nil if not started"
        - name: "completed_at"
          type: "*time.Time"
          description: "When spec execution finished"
          constraints: "ISO 8601 format, nil if not finished"
        - name: "current_stage"
          type: "string"
          description: "Current workflow stage"
          constraints: "One of: specify, plan, tasks, implement, empty if not running"
        - name: "blocked_by"
          type: "[]string"
          description: "List of spec IDs this spec is waiting on"
          constraints: "Empty when not blocked"
        - name: "failure_reason"
          type: "string"
          description: "Detailed error message with stage context if failed"
          constraints: "Empty if not failed; includes stage name and error details"
        - name: "exit_code"
          type: "*int"
          description: "Exit code of autospec run command"
          constraints: "nil if not completed"

    - name: "Executor"
      description: "Orchestrates the sequential execution of specs in a DAG"
      fields:
        - name: "dag"
          type: "*dag.DAGConfig"
          description: "Parsed DAG configuration"
          constraints: "Must be valid and validated"
        - name: "worktreeManager"
          type: "worktree.Manager"
          description: "Manager for creating worktrees"
          constraints: "Interface for testability"
        - name: "state"
          type: "*DAGRun"
          description: "Current run state"
          constraints: "Persisted after each state change"
        - name: "stateDir"
          type: "string"
          description: "Directory for state files"
          constraints: "Defaults to .autospec/state/dag-runs"
        - name: "logDir"
          type: "string"
          description: "Directory for log files"
          constraints: "Defaults to .autospec/state/dag-runs/<run-id>/logs"
        - name: "stdout"
          type: "io.Writer"
          description: "Output destination for prefixed output"
          constraints: "Typically os.Stdout"
        - name: "config"
          type: "*DAGExecutionConfig"
          description: "DAG and worktree configuration"
          constraints: "Loaded from config hierarchy"

    - name: "DAGExecutionConfig"
      description: "DAG-specific configuration from .autospec/config.yml"
      fields:
        - name: "onConflict"
          type: "string"
          description: "Default merge conflict handling"
          constraints: "One of: manual, agent"
        - name: "maxSpecRetries"
          type: "int"
          description: "Max auto-retry attempts per spec"
          constraints: "0 = manual only"
        - name: "maxLogSize"
          type: "string"
          description: "Max log file size per spec"
          constraints: "Size string like 50MB"

    - name: "WorktreeConfig"
      description: "Worktree configuration from .autospec/config.yml"
      fields:
        - name: "baseDir"
          type: "string"
          description: "Parent dir for worktrees"
          constraints: "Default: parent of repo"
        - name: "prefix"
          type: "string"
          description: "Directory name prefix"
          constraints: "e.g., wt-"
        - name: "setupScript"
          type: "string"
          description: "Custom setup script path"
          constraints: "Relative to repo"
        - name: "setupTimeout"
          type: "string"
          description: "Setup script timeout"
          constraints: "Duration string like 5m"
        - name: "copyDirs"
          type: "[]string"
          description: "Non-tracked dirs to copy to worktrees"
          constraints: "e.g., .autospec,.claude,.opencode"

    - name: "RunLock"
      description: "Lock file to prevent concurrent DAG runs"
      fields:
        - name: "runID"
          type: "string"
          description: "Identifier of the run holding the lock"
          constraints: "Must match current run"
        - name: "pid"
          type: "int"
          description: "Process ID holding the lock"
          constraints: "Used for stale detection"
        - name: "specs"
          type: "[]string"
          description: "List of spec IDs locked by this run"
          constraints: "Used for overlap detection"
        - name: "startedAt"
          type: "time.Time"
          description: "When lock was acquired"
          constraints: "ISO 8601 format"

api_contracts:
  endpoints: []

project_structure:
  documentation:
    - path: "specs/087-dag-run-sequential/spec.yaml"
      description: "Feature specification"
    - path: "specs/087-dag-run-sequential/plan.yaml"
      description: "Implementation plan (this file)"
    - path: "specs/087-dag-run-sequential/tasks.yaml"
      description: "Detailed task breakdown"
  source_code:
    - path: "internal/dag/executor.go"
      description: "DAG execution engine with sequential spec runner"
    - path: "internal/dag/runstate.go"
      description: "DAGRun and SpecState types with persistence logic"
    - path: "internal/dag/output.go"
      description: "Prefixed output writer and log file management"
    - path: "internal/dag/lock.go"
      description: "RunLock implementation for concurrent run prevention"
    - path: "internal/dag/config.go"
      description: "DAGExecutionConfig and WorktreeConfig types"
    - path: "internal/cli/dag/run.go"
      description: "CLI command for dag run with --dry-run and --force flags"
    - path: "internal/cli/dag/list.go"
      description: "CLI command for dag list"
  tests:
    - path: "internal/dag/executor_test.go"
      description: "Unit tests for executor"
    - path: "internal/dag/runstate_test.go"
      description: "Unit tests for state persistence"
    - path: "internal/dag/output_test.go"
      description: "Unit tests for output handling"
    - path: "internal/dag/lock_test.go"
      description: "Unit tests for run locking"
    - path: "internal/dag/config_test.go"
      description: "Unit tests for configuration loading"
    - path: "internal/cli/dag/run_test.go"
      description: "Integration tests for dag run command including dry-run"
    - path: "internal/cli/dag/list_test.go"
      description: "Unit tests for dag list command"

implementation_phases:
  - phase: 1
    name: "Configuration and State Foundation"
    goal: "Implement DAG/worktree configuration and DAGRun/SpecState types with atomic persistence"
    deliverables:
      - "DAGExecutionConfig and WorktreeConfig types in internal/dag/config.go"
      - "Configuration loading with env > project > user > defaults hierarchy"
      - "DAGRun and SpecState struct definitions in internal/dag/runstate.go"
      - "NewDAGRun() constructor generating unique run IDs"
      - "SaveState() and LoadState() with atomic write pattern"
      - "State directory creation logic (.autospec/state/dag-runs/)"
      - "Unit tests with map-based table-driven pattern"
  - phase: 2
    name: "Locking and Output Handling"
    goal: "Implement run locking and prefixed terminal output with per-spec log files"
    dependencies:
      - "Phase 1"
    deliverables:
      - "RunLock type with PID-based stale detection in internal/dag/lock.go"
      - "Lock acquisition, release, and overlap detection"
      - "PrefixedWriter type implementing io.Writer"
      - "Log file creation in .autospec/state/dag-runs/<run-id>/logs/"
      - "MultiWriter combining terminal and log output"
      - "Unit tests for locking and output prefixing behavior"
  - phase: 3
    name: "Executor Core"
    goal: "Implement the sequential execution engine with on-demand worktree creation"
    dependencies:
      - "Phase 1"
      - "Phase 2"
    deliverables:
      - "Executor struct with dependency injection"
      - "Layer-ordered execution loop"
      - "On-demand worktree creation with dag/<run-id>/<spec-id> branch naming"
      - "Existing worktree handling (skip if completed, prompt/force if failed)"
      - "Command execution (autospec run -spti) in worktree"
      - "Status tracking and state updates"
      - "Failure handling: stop execution, preserve worktree, output 'dag resume <run-id>' and 'dag retry <run-id> <spec> --clean' instructions"
      - "Unit tests with mocked dependencies"
  - phase: 4
    name: "CLI Commands"
    goal: "Implement dag run (with --dry-run, --force) and dag list commands"
    dependencies:
      - "Phase 3"
    deliverables:
      - "dag run command with file argument validation"
      - "--dry-run flag showing execution order, worktrees, existing vs new specs"
      - "--force flag for recreating failed/interrupted worktrees"
      - "dag list command showing all runs"
      - "Integration with lifecycle wrapper for history/notifications"
      - "Colored output for status display"
      - "Command tests"
  - phase: 5
    name: "Integration and Polish"
    goal: "End-to-end testing and final refinements"
    dependencies:
      - "Phase 4"
    deliverables:
      - "Integration tests with real DAG files"
      - "Edge case handling (empty DAG, single layer, all failures, existing worktrees)"
      - "Lock collision testing"
      - "make test && make fmt && make lint && make build all pass"

open_questions:
  - question: "Should the dag run command block until completion or return immediately?"
    context: "Spec mentions sequential execution but doesn't specify foreground vs background"
    proposed_resolution: "Block until completion (foreground execution) - background/detached mode would be a future enhancement"
    status: "Resolved - foreground execution"
  - question: "What happens if a worktree already exists for a spec?"
    context: "Could occur if previous run was interrupted or user manually created worktree"
    proposed_resolution: "Check state file: skip if completed, prompt/force if failed/interrupted, never silently overwrite"
    status: "Resolved - specified in updated spec"
  - question: "Should dag list show running runs or only completed ones?"
    context: "Spec shows run-id, status, timestamp for each run"
    proposed_resolution: "Show all runs including running ones - status field distinguishes them"
    status: "Resolved - show all runs"
  - question: "How should stale lock files be handled?"
    context: "Lock file may be left behind if process crashes without cleanup"
    proposed_resolution: "Lock file includes PID; check if PID is still running; treat as stale if process dead"
    status: "Resolved - PID-based stale detection"

_meta:
  version: "1.0.0"
  generator: "autospec"
  generator_version: "autospec 0.8.2"
  created: "2026-01-11T08:40:08Z"
  artifact_type: "plan"
