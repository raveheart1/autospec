plan:
  branch: "106-wire-template-rendering"
  created: "2026-01-28"
  spec_path: "specs/106-wire-template-rendering/spec.yaml"

summary: |
  This implementation wires the existing template rendering infrastructure into workflow execution.
  The core issue is that StageExecutor builds slash commands (e.g., "/autospec.plan") and passes them
  directly to Claude without rendering template variables like {{.FeatureDir}}. The solution follows
  the reference pattern from render-command CLI: call prereqs.ComputeContext() to get paths, then
  call commands.RenderTemplate() to replace variables before execution.

  The fix requires modifying StageExecutor methods (ExecutePlan, ExecuteTasks, ExecuteClarify,
  ExecuteChecklist, ExecuteAnalyze) to compute context and render the command template before
  passing to the Executor. ExecuteConstitution uses minimal context (version/date only).
  ExecuteSpecify doesn't use path variables, so it remains unchanged.

technical_context:
  language: "Go"
  framework: "None"
  primary_dependencies:
    - name: "internal/prereqs"
      version: "internal"
      purpose: "ComputeContext() for path detection from git branch"
    - name: "internal/commands"
      version: "internal"
      purpose: "GetTemplate(), RenderTemplate() for template rendering"
    - name: "internal/spec"
      version: "internal"
      purpose: "DetectCurrentSpec() for spec metadata"
    - name: "text/template"
      version: "stdlib"
      purpose: "Go template engine used by RenderTemplate"
  storage: "None"
  testing:
    framework: "testing (stdlib)"
    approach: "Unit tests with map-based table tests for each affected method"
  target_platform: "Linux, macOS, Windows"
  project_type: "cli"
  performance_goals: "Template rendering under 100ms per NFR-006"
  constraints:
    - "Must use existing prereqs.ComputeContext() and commands.RenderTemplate()"
    - "Must not change template variable syntax"
    - "Must maintain backward compatibility with manual path specification"
    - "Must not require changes to Claude Code"
  scale_scope: "Small change - primarily internal/workflow/stage_executor.go"

constitution_check:
  constitution_path: ".autospec/memory/constitution.yaml"
  gates:
    - name: "Test-First Development"
      status: "PASS"
      notes: "Tests will be written for template rendering integration before implementation"
    - name: "Idiomatic Go"
      status: "PASS"
      notes: "Will follow Go conventions: error wrapping, short functions, table tests"
    - name: "Performance Standards"
      status: "PASS"
      notes: "Template rendering is lightweight text substitution, under 100ms"
    - name: "Idempotent Operations"
      status: "PASS"
      notes: "Template rendering is idempotent per NFR-005"
    - name: "Validation-First Workflow"
      status: "PASS"
      notes: "Context validation happens via prereqs.ComputeContext options"
    - name: "Command Template Independence"
      status: "PASS"
      notes: "Templates remain project-agnostic, only paths are injected"
    - name: "Actionable Errors"
      status: "PASS"
      notes: "prereqs.ComputeContext already provides actionable error messages per FR-005"
    - name: "Schema-Driven Artifacts"
      status: "N/A"
      notes: "This change doesn't affect artifact schemas"

research_findings:
  decisions:
    - topic: "Where to add template rendering"
      decision: "Add rendering in StageExecutor methods before calling executor.ExecuteStage()"
      rationale: "StageExecutor is responsible for building commands; keeps rendering close to command construction"
      alternatives_considered:
        - "Add in Executor.ExecuteStage() - rejected: would require passing template context through interface"
        - "Add in ClaudeExecutor.Execute() - rejected: too late, command string already built"
    - topic: "How to get template content"
      decision: "Use commands.GetTemplate() with stage-to-command name mapping"
      rationale: "Matches render-command CLI pattern; templates are embedded and accessible"
      alternatives_considered:
        - "Read from .claude/commands/ filesystem - rejected: may not exist, embedded is reliable"
    - topic: "Context computation per command"
      decision: "Map each command to appropriate prereqs.Options based on RequiredVars"
      rationale: "Different commands need different file existence checks (spec only vs spec+plan)"
      alternatives_considered:
        - "Compute full context always - rejected: would fail unnecessarily for early stages"
    - topic: "Helper function pattern"
      decision: "Create computeAndRenderCommand() helper in stage_executor.go"
      rationale: "Extracts shared logic, keeps each Execute* method short (under 40 lines)"
      alternatives_considered:
        - "Inline in each method - rejected: code duplication, longer functions"

data_model:
  entities:
    - name: "prereqs.Context"
      description: "Pre-computed template variables for command rendering"
      fields:
        - name: "FeatureDir"
          type: "string"
          description: "Path to feature directory (e.g., specs/106-wire-template-rendering)"
          constraints: "Must exist when RequireSpec is true"
        - name: "FeatureSpec"
          type: "string"
          description: "Path to spec.yaml file"
          constraints: "Must exist when RequireSpec is true"
        - name: "ImplPlan"
          type: "string"
          description: "Path to plan.yaml file"
          constraints: "Must exist when RequirePlan is true"
        - name: "TasksFile"
          type: "string"
          description: "Path to tasks.yaml file"
          constraints: "Must exist when RequireTasks is true"
        - name: "AutospecVersion"
          type: "string"
          description: "Current autospec version (e.g., 'autospec 0.10.1')"
          constraints: "Always populated"
        - name: "CreatedDate"
          type: "string"
          description: "ISO 8601 timestamp"
          constraints: "Always populated"
        - name: "IsGitRepo"
          type: "bool"
          description: "Whether current directory is a git repository"
          constraints: "Always populated"
      relationships:
        - target: "commands.RenderTemplate"
          type: "parameter"
          description: "Context is passed to RenderTemplate for variable substitution"
    - name: "prereqs.Options"
      description: "Configuration for ComputeContext behavior"
      fields:
        - name: "SpecsDir"
          type: "string"
          description: "Base directory for specs (default: ./specs)"
          constraints: "Directory path"
        - name: "RequireSpec"
          type: "bool"
          description: "Require spec.yaml to exist"
          constraints: "Boolean"
        - name: "RequirePlan"
          type: "bool"
          description: "Require plan.yaml to exist"
          constraints: "Boolean"
        - name: "RequireTasks"
          type: "bool"
          description: "Require tasks.yaml to exist"
          constraints: "Boolean"
        - name: "PathsOnly"
          type: "bool"
          description: "Skip file existence validation"
          constraints: "Boolean"
      relationships:
        - target: "prereqs.ComputeContext"
          type: "parameter"
          description: "Options control validation behavior"

api_contracts:
  endpoints: []

project_structure:
  documentation:
    - path: "docs/public/reference.md"
      description: "CLI reference - no changes needed"
  source_code:
    - path: "internal/workflow/stage_executor.go"
      description: "Primary modification target - add template rendering to Execute* methods"
    - path: "internal/prereqs/context.go"
      description: "Existing - provides ComputeContext() (no changes needed)"
    - path: "internal/commands/render.go"
      description: "Existing - provides RenderTemplate() (no changes needed)"
    - path: "internal/commands/embed.go"
      description: "Existing - provides GetTemplate() (no changes needed)"
  tests:
    - path: "internal/workflow/stage_executor_test.go"
      description: "New tests for template rendering integration"

implementation_phases:
  - phase: 1
    name: "Setup"
    goal: "Understand existing patterns and prepare test infrastructure"
    deliverables:
      - "Review render-command CLI implementation pattern"
      - "Create test file structure for stage_executor_test.go"
  - phase: 2
    name: "Core Implementation"
    goal: "Add template rendering to StageExecutor"
    dependencies:
      - "Phase 1"
    deliverables:
      - "Add computeAndRenderCommand() helper function"
      - "Add getOptionsForStage() helper for stage-specific prereqs options"
      - "Modify ExecutePlan to render template before execution"
      - "Modify ExecuteTasks to render template before execution"
      - "Modify ExecuteImplement-related methods (via PhaseExecutor/TaskExecutor)"
      - "Modify ExecuteClarify to render template before execution"
      - "Modify ExecuteChecklist to render template before execution"
      - "Modify ExecuteAnalyze to render template before execution"
  - phase: 3
    name: "Testing"
    goal: "Comprehensive test coverage for template rendering"
    dependencies:
      - "Phase 2"
    deliverables:
      - "Unit tests for computeAndRenderCommand()"
      - "Unit tests for each modified Execute* method"
      - "Integration test verifying end-to-end rendering"
      - "Edge case tests (missing spec, detached HEAD, etc.)"
  - phase: 4
    name: "Polish"
    goal: "Final validation and cleanup"
    dependencies:
      - "Phase 3"
    deliverables:
      - "Run make test && make fmt && make lint && make build"
      - "Manual testing with autospec run"
      - "Create manual testing plan document"
      - "Update changelog"

open_questions:
  - question: "Should PhaseExecutor and TaskExecutor also get template rendering?"
    context: "These executors build implement commands with --phase and --task flags"
    proposed_resolution: "Yes - they use {{.FeatureDir}} and {{.TasksFile}} variables. Add rendering to their command-building methods."
  - question: "How to handle the implement command which reads from context file?"
    context: "Implement uses --context-file flag with bundled artifacts"
    proposed_resolution: "Context file rendering is separate - the template variables in the base implement command still need rendering."

_meta:
  version: "1.0.0"
  generator: "autospec"
  generator_version: "autospec 0.10.1"
  created: "2026-01-28T09:33:23Z"
  artifact_type: "plan"
