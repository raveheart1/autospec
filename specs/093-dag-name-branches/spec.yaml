feature:
    branch: "093-dag-name-branches"
    created: "2026-01-11"
    status: "Completed"
    completed_at: 2026-01-11T20:55:26Z
    input: |
        Spec 8: DAG Name in Branch Names - Generate human-readable branch names from DAG name/id instead of
        opaque run IDs. Branch format changes from dag/20260111_112034_ba7166b1/200-repo-reader to
        dag/gitstats-cli-v1/200-repo-reader. Includes slug generation from dag.name, optional dag.id override,
        collision handling, ID immutability once state exists, and uniqueness validation across DAG files.
user_stories:
    - id: "US-001"
      title: "Self-documenting branch names"
      priority: "P1"
      as_a: "developer managing multiple DAG runs"
      i_want: "branch names that identify which DAG they belong to"
      so_that: "I can understand my git branch list without looking up run IDs"
      why_this_priority: "Core value proposition - without this, the feature provides no benefit"
      independent_test: "Run a DAG and verify branch names contain the DAG name slug"
      acceptance_scenarios:
        - given: "A DAG workflow with name 'GitStats CLI v1'"
          when: "I run 'dag run workflow.yaml'"
          then: "Branches are created as dag/gitstats-cli-v1/<spec-id>"
        - given: "Multiple branches from different DAGs"
          when: "I run 'git branch -a'"
          then: "I can identify which branches belong to which DAG by reading branch names"
    - id: "US-002"
      title: "Override generated slug with explicit ID"
      priority: "P2"
      as_a: "power user with specific naming requirements"
      i_want: "to specify an explicit ID that overrides the auto-generated slug"
      so_that: "I can use shorter or custom identifiers when the auto-slug is undesirable"
      why_this_priority: "Enhancement for power users; auto-slug covers most cases"
      independent_test: "Set dag.id in YAML and verify it's used instead of slugified name"
      acceptance_scenarios:
        - given: "A DAG with name 'My Very Long Feature Name v1' and id 'mvlfn'"
          when: "I run the DAG"
          then: "Branches use 'mvlfn' instead of 'my-very-long-feature-name-v1'"
    - id: "US-003"
      title: "Resume existing DAG run"
      priority: "P1"
      as_a: "developer with an interrupted DAG run"
      i_want: "to resume using the same branches as before"
      so_that: "I don't lose work or create duplicate branches"
      why_this_priority: "Critical for idempotent operation - core system requirement"
      independent_test: "Stop a DAG run, restart it, verify existing branches are reused"
      acceptance_scenarios:
        - given: "A partially completed DAG run with existing branches"
          when: "I run 'dag run workflow.yaml' again"
          then: "Existing branches and worktrees are reused, not recreated"
    - id: "US-004"
      title: "Detect DAG ID changes"
      priority: "P1"
      as_a: "developer who accidentally modified the DAG name"
      i_want: "to be warned if the resolved ID would change from what's in state"
      so_that: "I don't accidentally orphan my existing branches and worktrees"
      why_this_priority: "Prevents confusing state corruption - essential for reliability"
      independent_test: "Change dag.name after first run, verify error message appears"
      acceptance_scenarios:
        - given: "A DAG run with state file storing ID 'gitstats-cli-v1'"
          when: "I modify dag.name to resolve to 'gitstats-v2' and run again"
          then: "An error appears explaining the mismatch and offering solutions"
    - id: "US-005"
      title: "Handle naming collisions"
      priority: "P2"
      as_a: "developer running multiple DAGs with similar names"
      i_want: "collisions to be handled gracefully"
      so_that: "I can run multiple DAGs without manual branch management"
      why_this_priority: "Edge case handling - most users won't encounter this"
      independent_test: "Create two DAGs with same resolved ID, verify collision handling"
      acceptance_scenarios:
        - given: "A branch 'dag/mydag/200-spec' already exists from a different DAG"
          when: "A new DAG resolves to the same ID"
          then: "A suffix is appended to create a unique branch name"
    - id: "US-006"
      title: "Validate DAG uniqueness"
      priority: "P2"
      as_a: "team lead managing multiple DAG definitions"
      i_want: "validation to catch duplicate IDs before runtime errors"
      so_that: "I can prevent naming conflicts proactively"
      why_this_priority: "Prevents runtime surprises but not blocking for basic usage"
      independent_test: "Create two DAGs with same ID, run 'dag validate', verify error"
      acceptance_scenarios:
        - given: "Two DAG files with the same resolved ID"
          when: "I run 'autospec dag validate .autospec/dags/'"
          then: "An error identifies both files and the duplicate ID"
requirements:
    functional:
        - id: "FR-001"
          description: "The system MUST generate a slug from dag.name when dag.id is not specified"
          testable: true
          acceptance_criteria: "Slugify function produces lowercase, hyphen-separated output from any input string"
        - id: "FR-002"
          description: "The system MUST use dag.id directly when specified, bypassing slug generation"
          testable: true
          acceptance_criteria: "DAG with explicit id uses that value in branch names"
        - id: "FR-003"
          description: "The system MUST create branches in format dag/<resolved-id>/<spec-id>"
          testable: true
          acceptance_criteria: "Branch names match the specified format for all specs in a DAG"
        - id: "FR-004"
          description: "The system MUST create worktree directories in format dag-<resolved-id>-<spec-id>"
          testable: true
          acceptance_criteria: "Worktree directories match the specified naming format"
        - id: "FR-005"
          description: "The system MUST fall back to workflow filename when neither dag.id nor dag.name is specified"
          testable: true
          acceptance_criteria: "Workflow 'features/v1.yaml' produces branches with 'v1' as the ID component"
        - id: "FR-006"
          description: "The system MUST store the resolved ID in state files at first run"
          testable: true
          acceptance_criteria: "State file contains dag_id field after first DAG run"
        - id: "FR-007"
          description: "The system MUST error when resolved ID differs from stored ID in state"
          testable: true
          acceptance_criteria: "Modifying dag.name/id to produce different slug results in clear error message"
        - id: "FR-008"
          description: "The system MUST reuse existing branches and worktrees on resume"
          testable: true
          acceptance_criteria: "Running dag run twice uses same branches, no duplicate creation"
        - id: "FR-009"
          description: "The system SHOULD append a short hash suffix when branch name collides with different DAG"
          testable: true
          acceptance_criteria: "Collision produces unique branch name with hash suffix"
        - id: "FR-010"
          description: "The dag validate command MUST detect duplicate resolved IDs across DAG files"
          testable: true
          acceptance_criteria: "Validation fails with specific error when two files have same ID"
        - id: "FR-011"
          description: "The dag validate command SHOULD warn about duplicate dag.name values"
          testable: true
          acceptance_criteria: "Validation produces warning when two files have same name"
        - id: "FR-012"
          description: "Slug generation MUST truncate output to 50 characters maximum"
          testable: true
          acceptance_criteria: "Input longer than 50 chars produces output of exactly 50 chars or less"
        - id: "FR-013"
          description: "Existing runs with old-format branches MUST continue to work"
          testable: true
          acceptance_criteria: "State files with old timestamp-based branches can still be resumed"
        - id: "FR-014"
          description: "The system MUST pass all quality gates: make test && make fmt && make lint && make build"
          testable: true
          acceptance_criteria: "All commands exit with code 0"
    non_functional:
        - id: "NFR-001"
          category: "code_quality"
          description: "Functions MUST be under 40 lines"
          measurable_target: "No function exceeds 40 lines"
        - id: "NFR-002"
          category: "code_quality"
          description: "Errors MUST be wrapped with context using fmt.Errorf"
          measurable_target: "All error returns include descriptive context"
        - id: "NFR-003"
          category: "code_quality"
          description: "Tests MUST use map-based table test pattern"
          measurable_target: "All test functions use map[string]struct{} pattern"
        - id: "NFR-004"
          category: "code_quality"
          description: "Functions SHOULD accept interfaces, return concrete types"
          measurable_target: "Interface parameters used where polymorphism needed"
        - id: "NFR-005"
          category: "usability"
          description: "Error messages MUST provide actionable guidance"
          measurable_target: "ID mismatch errors include specific remediation options"
        - id: "NFR-006"
          category: "reliability"
          description: "Slug generation MUST be deterministic"
          measurable_target: "Same input always produces same output"
success_criteria:
    measurable_outcomes:
        - id: "SC-001"
          description: "Users can identify which DAG a branch belongs to by reading the branch name"
          metric: "Branch name contains human-readable DAG identifier"
          target: "100% of new branches include DAG slug in name"
        - id: "SC-002"
          description: "Git branch listings are immediately interpretable without external lookups"
          metric: "DAG identity visible in 'git branch' output"
          target: "No timestamp/hash-based identifiers in branch names"
        - id: "SC-003"
          description: "Existing DAG runs continue working after upgrade"
          metric: "Backward compatibility with old state files"
          target: "100% of old-format runs resumable"
        - id: "SC-004"
          description: "Users are prevented from accidentally orphaning branches"
          metric: "ID mismatch detection rate"
          target: "100% of ID changes detected with clear error"
        - id: "SC-005"
          description: "Duplicate DAG IDs are caught before runtime"
          metric: "Validation coverage"
          target: "dag validate catches all duplicate IDs in scanned directory"
key_entities:
    - name: "DAG"
      description: "Workflow definition containing name, optional id, and spec references"
      attributes:
        - "name: display name for the DAG"
        - "id: optional explicit identifier override"
        - "resolved_id: computed from id or slugified name"
    - name: "Slug"
      description: "URL-safe identifier generated from human-readable text"
      attributes:
        - "lowercase letters and numbers only"
        - "hyphens as word separators"
        - "maximum 50 characters"
    - name: "State File"
      description: "Persisted run state including locked DAG ID"
      attributes:
        - "dag_id: resolved ID locked at first run"
        - "dag_name: snapshot of name at first run"
        - "specs: map of spec status and branch/worktree paths"
    - name: "Branch Name"
      description: "Git branch identifier for a spec within a DAG run"
      attributes:
        - "format: dag/<resolved-id>/<spec-id>"
        - "collision suffix: optional hash for uniqueness"
edge_cases:
    - scenario: "dag.name contains only special characters"
      expected_behavior: "Fall back to workflow filename for ID"
    - scenario: "dag.name is empty string"
      expected_behavior: "Fall back to workflow filename for ID"
    - scenario: "Very long dag.name exceeds 50 characters after slugification"
      expected_behavior: "Truncate to 50 characters at word boundary if possible"
    - scenario: "Two DAGs have names that slugify to the same value"
      expected_behavior: "dag validate warns; runtime adds hash suffix on collision"
    - scenario: "User changes dag.name but dag.id is set"
      expected_behavior: "No error - id is used, name is display-only"
    - scenario: "State file exists but workflow file is deleted and recreated"
      expected_behavior: "ID mismatch error if resolved ID differs from state"
    - scenario: "Mixed old-format and new-format branches in same repo"
      expected_behavior: "Each run uses its own recorded branch names from state"
    - scenario: "dag.id contains invalid characters for git branch names"
      expected_behavior: "Slugify the id as well, or error if result is empty"
assumptions:
    - "Git branch names support the slash character for hierarchical naming"
    - "Worktree directories are created adjacent to the main repo directory"
    - "State files are stored in .autospec/state/dag-runs/ directory"
    - "The slugify operation is performed at DAG load time, not lazily"
    - "Old-format branches used timestamp_hash pattern that is no longer generated"
constraints:
    - "Branch names must be valid git ref names"
    - "Worktree directory names must be valid filesystem paths"
    - "Slug length limited to 50 characters for readability"
    - "Cannot rename existing branches when ID would change - must use --fresh"
out_of_scope:
    - "State file naming changes (covered in spec-7)"
    - "Custom branch prefix configuration beyond 'dag/'"
    - "Automatic branch rename/migration command"
    - "Remote branch synchronization on ID change"
    - "UI/dashboard for visualizing DAG branches"
_meta:
    version: "1.0.0"
    generator: "autospec"
    generator_version: "autospec v0.8.2"
    created: "2026-01-11T20:21:09Z"
    artifact_type: "spec"
