feature:
  branch: "088-dag-parallel-status"
  created: "2026-01-11"
  status: "Draft"
  input: |
    Part of DAG Multi-Spec Orchestration - a meta-orchestrator that runs multiple autospec run workflows
    in parallel across worktrees with dependency management. Scope: Parallel execution with concurrency
    control and unified status view. Commands: autospec dag run <file> --parallel, autospec dag run
    --max-parallel N, autospec dag status [run-id]. Key deliverables: Parallel process management using
    errgroup with SetLimit(maxParallel), output multiplexing with [spec-id] prefixes, progress tracking
    (X/Y specs complete), graceful Ctrl-C handling (save state before exit), dag status showing completed,
    running, pending, failed specs with progress.

user_stories:
  - id: "US-001"
    title: "Run multiple specs in parallel"
    priority: "P1"
    as_a: "developer orchestrating multiple feature specs"
    i_want: "to run multiple spec workflows concurrently with controlled parallelism"
    so_that: "I can complete multi-spec projects faster while staying within system resource limits"
    why_this_priority: "Core capability - parallel execution is the primary value proposition of this feature"
    independent_test: "Run a DAG file with 4 independent specs using --max-parallel 2 and verify only 2 run at a time"
    acceptance_scenarios:
      - given: "a DAG file with 5 specs where 3 have no dependencies"
        when: "I run 'autospec dag run file.yaml --parallel --max-parallel 2'"
        then: "at most 2 specs execute concurrently, and the 3rd independent spec starts when one completes"
      - given: "a DAG file with dependent specs A→B→C and independent spec D"
        when: "I run with --max-parallel 3"
        then: "A and D run concurrently, B starts after A completes, C starts after B completes"

  - id: "US-002"
    title: "View unified status of DAG execution"
    priority: "P1"
    as_a: "developer managing a multi-spec run"
    i_want: "to see a unified status view showing all spec states and progress"
    so_that: "I can understand overall progress and identify which specs need attention"
    why_this_priority: "Essential for usability - without status visibility, parallel execution is unmanageable"
    independent_test: "Start a parallel DAG run and invoke dag status to verify it shows correct states for each spec"
    acceptance_scenarios:
      - given: "a DAG run is in progress with 1 completed, 2 running, and 2 pending specs"
        when: "I run 'autospec dag status'"
        then: "I see categorized output showing completed specs with duration, running specs with current stage/task, and pending specs with blocking dependencies"
      - given: "multiple DAG runs have been executed"
        when: "I run 'autospec dag status run-id'"
        then: "I see the status for that specific run"

  - id: "US-003"
    title: "Distinguish output from concurrent specs"
    priority: "P1"
    as_a: "developer monitoring parallel execution"
    i_want: "output from concurrent specs to be clearly labeled with spec identifiers"
    so_that: "I can distinguish which spec produced which output in the combined stream"
    why_this_priority: "Critical for debugging - interleaved output without labels would be unusable"
    independent_test: "Run 2 specs in parallel and verify each output line is prefixed with its spec identifier"
    acceptance_scenarios:
      - given: "two specs are running concurrently"
        when: "both specs produce output simultaneously"
        then: "each output line is prefixed with [spec-id] showing which spec produced it"

  - id: "US-004"
    title: "Track overall progress"
    priority: "P2"
    as_a: "developer running a large DAG"
    i_want: "to see progress indicators showing how many specs are complete"
    so_that: "I can estimate remaining time and verify the run is progressing"
    why_this_priority: "Important for user experience but run can function without explicit progress display"
    independent_test: "Run a DAG with 5 specs and verify progress updates from 0/5 to 5/5 as specs complete"
    acceptance_scenarios:
      - given: "a DAG run is in progress"
        when: "specs complete during execution"
        then: "progress indicator updates to show X/Y specs complete"

  - id: "US-005"
    title: "Graceful interruption handling"
    priority: "P1"
    as_a: "developer who needs to stop a DAG run"
    i_want: "Ctrl-C to gracefully stop execution and save current state"
    so_that: "I don't lose progress data and can understand what completed before interruption"
    why_this_priority: "Essential for reliability - ungraceful interruption could leave system in inconsistent state"
    independent_test: "Start a DAG run, send SIGINT, and verify state is saved before exit"
    acceptance_scenarios:
      - given: "a DAG run is in progress with 2 running specs"
        when: "I press Ctrl-C"
        then: "running specs are signaled to stop, state is saved showing which completed and which were interrupted, and process exits cleanly"

  - id: "US-006"
    title: "Continue despite individual spec failures"
    priority: "P1"
    as_a: "developer running independent specs"
    i_want: "the run to continue when one spec fails, only blocking dependent specs"
    so_that: "I get maximum progress from a single run even when some specs have issues"
    why_this_priority: "Core failure handling - maximizes value from each run"
    independent_test: "Run a DAG where an early independent spec fails and verify other independent specs complete"
    acceptance_scenarios:
      - given: "a DAG with specs A, B (depends on A), and C (independent)"
        when: "spec A fails"
        then: "spec B is marked as blocked, spec C continues to completion, run completes with partial success"

  - id: "US-007"
    title: "Fail fast option"
    priority: "P2"
    as_a: "developer who wants to stop on first failure"
    i_want: "an option to abort the entire run when any spec fails"
    so_that: "I can quickly identify and fix the issue without waiting for other specs"
    why_this_priority: "Useful optimization for iterative development but default behavior is more commonly needed"
    independent_test: "Run with --fail-fast, have one spec fail, verify all running specs are stopped"
    acceptance_scenarios:
      - given: "a DAG run with --fail-fast flag and 3 specs running"
        when: "one spec fails"
        then: "remaining running specs are signaled to stop, state is saved immediately, process exits with error"

requirements:
  functional:
    - id: "FR-001"
      description: "The system MUST support --parallel flag on dag run command to enable concurrent execution"
      testable: true
      acceptance_criteria: "Command accepts --parallel flag and executes specs concurrently instead of sequentially"

    - id: "FR-002"
      description: "The system MUST support --max-parallel N flag to limit concurrent spec count"
      testable: true
      acceptance_criteria: "With --max-parallel 2, never more than 2 specs execute simultaneously regardless of how many are ready"

    - id: "FR-003"
      description: "The system MUST default to max_parallel=4 when --parallel is specified without --max-parallel"
      testable: true
      acceptance_criteria: "Running with only --parallel limits concurrency to 4 specs"

    - id: "FR-004"
      description: "The system MUST prefix all spec output with [spec-id] during parallel execution"
      testable: true
      acceptance_criteria: "Every line of output from a spec includes the spec identifier prefix"

    - id: "FR-005"
      description: "The system MUST display progress as X/Y specs complete during execution"
      testable: true
      acceptance_criteria: "Progress indicator updates as each spec completes"

    - id: "FR-006"
      description: "The system MUST handle SIGINT by saving state and exiting gracefully"
      testable: true
      acceptance_criteria: "On Ctrl-C, state file is written before process exits, containing completion status of all specs"

    - id: "FR-007"
      description: "The system MUST implement dag status command showing categorized spec states"
      testable: true
      acceptance_criteria: "Command outputs specs grouped by: completed (with duration), running (with current stage/task), pending (with blocking dependencies), failed"

    - id: "FR-008"
      description: "The system MUST mark specs as blocked when their dependencies fail"
      testable: true
      acceptance_criteria: "When spec A fails, any pending spec with A as a dependency shows 'blocked by: A'"

    - id: "FR-009"
      description: "The system MUST continue running non-dependent specs when one spec fails (default behavior)"
      testable: true
      acceptance_criteria: "Failure of one spec does not stop execution of specs that don't depend on it"

    - id: "FR-010"
      description: "The system MUST support --fail-fast flag to abort on first failure"
      testable: true
      acceptance_criteria: "With --fail-fast, first failure signals all running specs to stop and saves state immediately"

    - id: "FR-011"
      description: "The system MUST use errgroup with SetLimit for concurrency control"
      testable: true
      acceptance_criteria: "Implementation uses golang.org/x/sync/errgroup with SetLimit(maxParallel)"

    - id: "FR-012"
      description: "The system MUST check for newly unblocked specs as each spec completes"
      testable: true
      acceptance_criteria: "When a spec completes, any pending specs whose dependencies are now satisfied are queued for execution"

    - id: "FR-013"
      description: "The system MUST support dag status with optional run-id parameter"
      testable: true
      acceptance_criteria: "dag status without run-id shows most recent run; with run-id shows that specific run"

    - id: "FR-014"
      description: "Functions MUST be under 40 lines"
      testable: true
      acceptance_criteria: "No function exceeds 40 lines; complex logic extracted to helper functions"

    - id: "FR-015"
      description: "Errors MUST be wrapped with context using fmt.Errorf with %w"
      testable: true
      acceptance_criteria: "All error returns use fmt.Errorf('context: %w', err) pattern"

    - id: "FR-016"
      description: "Tests MUST use map-based table test pattern"
      testable: true
      acceptance_criteria: "Tests use map[string]struct{} with for name, tt := range tests { t.Run(name, ...) }"

    - id: "FR-017"
      description: "Build pipeline MUST pass: make test && make fmt && make lint && make build"
      testable: true
      acceptance_criteria: "All four commands exit with code 0"

  non_functional:
    - id: "NFR-001"
      category: "performance"
      description: "Parallel execution overhead MUST NOT exceed 10% of total sequential execution time"
      measurable_target: "Overhead measured as (parallel time with max-parallel=1) / (sequential time) < 1.10"

    - id: "NFR-002"
      category: "reliability"
      description: "State MUST be saved within 2 seconds of receiving SIGINT"
      measurable_target: "Time from SIGINT to state file written < 2 seconds"

    - id: "NFR-003"
      category: "usability"
      description: "Status output MUST be readable and well-organized with clear visual hierarchy"
      measurable_target: "Status uses consistent formatting with symbols (checkmarks, spinners, circles) and proper alignment"

    - id: "NFR-004"
      category: "reliability"
      description: "No data races in concurrent execution"
      measurable_target: "go test -race passes with zero race conditions detected"

success_criteria:
  measurable_outcomes:
    - id: "SC-001"
      description: "Users can run multiple spec workflows concurrently with configurable parallelism"
      metric: "Number of concurrent specs limited to configured max-parallel value"
      target: "At most N specs running when --max-parallel N is specified"

    - id: "SC-002"
      description: "Users can view current status of all specs in a DAG run"
      metric: "Status command shows accurate state for each spec"
      target: "100% of specs shown with correct status category (completed/running/pending/blocked/failed)"

    - id: "SC-003"
      description: "Users can identify which spec produced each output line"
      metric: "Output lines correctly prefixed with spec identifier"
      target: "100% of output lines have [spec-id] prefix during parallel execution"

    - id: "SC-004"
      description: "Users can safely interrupt a DAG run without data loss"
      metric: "State preservation on interruption"
      target: "State file contains accurate completion status for all specs after SIGINT"

    - id: "SC-005"
      description: "Failed specs do not block unrelated specs from completing"
      metric: "Independent specs complete despite other spec failures"
      target: "Specs with no dependency on failed spec run to completion"

key_entities:
  - name: "DAGRun"
    description: "Represents a single execution of a DAG file, tracking all spec states and progress"
    attributes:
      - "run_id: unique identifier (dag-YYYYMMDD-HHMMSS format)"
      - "dag_file: path to the DAG definition file"
      - "status: overall run status (running/completed/failed/interrupted)"
      - "specs: collection of spec execution states"
      - "started_at: timestamp when run began"
      - "completed_at: timestamp when run ended (if finished)"

  - name: "SpecExecution"
    description: "Tracks the execution state of a single spec within a DAG run"
    attributes:
      - "spec_id: identifier for the spec (e.g., 050-error-handling)"
      - "status: current status (pending/running/completed/failed/blocked)"
      - "blocking_dependencies: list of spec-ids this spec is waiting on"
      - "current_stage: stage being executed if running (specify/plan/tasks/implement)"
      - "current_task: task number if in implement stage (e.g., 8/12)"
      - "duration: elapsed time if completed"
      - "error: failure message if failed"

  - name: "ParallelExecutor"
    description: "Manages concurrent execution of specs with controlled parallelism"
    attributes:
      - "max_parallel: maximum concurrent specs allowed"
      - "running_count: current number of executing specs"
      - "errgroup: golang errgroup for concurrency management"

edge_cases:
  - scenario: "All specs fail in parallel run"
    expected_behavior: "Run completes with failed status, all specs shown as failed in status output"

  - scenario: "Circular dependency detected during parallel execution"
    expected_behavior: "Should be caught by DAG validation before parallel execution begins (from Spec 1)"

  - scenario: "max-parallel set higher than available specs"
    expected_behavior: "All ready specs run immediately, no error - max-parallel is a limit not a requirement"

  - scenario: "max-parallel set to 0"
    expected_behavior: "Treated as error - must be at least 1"

  - scenario: "SIGINT received with no specs currently running"
    expected_behavior: "State saved with current pending specs, exit immediately"

  - scenario: "SIGINT received while spec is in middle of stage"
    expected_behavior: "Signal propagated to running agent processes, wait briefly for graceful shutdown, then save state and exit"

  - scenario: "Spec output contains characters that look like prefix format"
    expected_behavior: "Actual prefix uses consistent format that won't conflict (e.g., [spec-id] at line start only)"

  - scenario: "Two specs complete at exact same moment"
    expected_behavior: "Both handled correctly due to errgroup synchronization, no race condition"

  - scenario: "dag status called with invalid run-id"
    expected_behavior: "Clear error message: 'run not found: <run-id>'"

  - scenario: "dag status called when no runs exist"
    expected_behavior: "Clear message: 'no DAG runs found'"

assumptions:
  - "Existing sequential dag run (Spec 2) provides the foundation for dependency resolution and execution flow"
  - "errgroup from golang.org/x/sync is available and appropriate for this use case"
  - "Each parallel spec execution uses its own worktree as established in the worktree system"
  - "Agent processes (claude, etc.) can be signaled for graceful shutdown via context cancellation"
  - "State persistence mechanism from Spec 2 can be extended to track parallel execution states"
  - "Users understand that concurrent modification of shared files (go.mod, package.json) is discouraged"

constraints:
  - "Must build on existing dag run sequential implementation (Spec 2)"
  - "Cannot implement resume capability (deferred to Spec 4)"
  - "Cannot implement automatic merge (deferred to Spec 4)"
  - "No automatic detection of shared file conflicts between concurrent specs"
  - "No API rate limit detection or adaptive backoff for agent API calls"
  - "Sequential mode (max-parallel=1) must remain available for constrained environments"

out_of_scope:
  - "Resume capability for interrupted runs (Spec 4)"
  - "Automatic merge of completed spec branches (Spec 4)"
  - "API rate limit detection and automatic backoff"
  - "Automatic detection or prevention of concurrent file modification conflicts"
  - "Dynamic adjustment of parallelism based on system load"
  - "Distributed execution across multiple machines"
  - "Web UI for status monitoring"
  - "Historical run analytics or reporting"

_meta:
  version: "1.0.0"
  generator: "autospec"
  generator_version: "autospec 0.8.2"
  created: "2026-01-11T09:15:49Z"
  artifact_type: "spec"
