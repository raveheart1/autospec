//go:build e2e

// Package e2e provides end-to-end tests for the autospec CLI.
package e2e

import (
	"os"
	"path/filepath"
	"strings"
	"testing"

	"github.com/ariel-frischer/autospec/internal/testutil"
	"github.com/stretchr/testify/require"
)

// TestE2E_OpenCodeWorkflow verifies that autospec can execute workflows
// using the OpenCode agent preset (US-002, FR-005).
func TestE2E_OpenCodeWorkflow(t *testing.T) {
	tests := map[string]struct {
		description     string
		setupFunc       func(t *testing.T, env *testutil.E2EEnv)
		command         []string
		verifyFunc      func(t *testing.T, env *testutil.E2EEnv, result testutil.CommandResult)
		mockExitCode    int
		setMockExitCode bool
	}{
		"specify with --agent opencode generates spec.yaml": {
			description: "Run specify command with OpenCode agent and verify spec artifact is created",
			setupFunc: func(t *testing.T, env *testutil.E2EEnv) {
				t.Helper()
				env.InitGitRepo()
				env.CreateBranch("001-test-feature")
				env.SetupConstitution()
				env.SetupAutospecInit()
				env.SetAgentPreset(testutil.AgentOpencode)
			},
			command: []string{"specify", "test feature", "--agent", "opencode"},
			verifyFunc: func(t *testing.T, env *testutil.E2EEnv, result testutil.CommandResult) {
				t.Helper()
				// Verify command completed (may have exit code 0 or 1 depending on validation)
				// The main goal is that mock-opencode.sh was invoked
				require.True(t, env.SpecExists("001-test-feature"),
					"spec.yaml should be generated by mock-opencode.sh")
			},
		},
		"mock-opencode.sh is invoked via MOCK_CALL_LOG": {
			description: "Verify mock-opencode.sh logs invocations when MOCK_CALL_LOG is set",
			setupFunc: func(t *testing.T, env *testutil.E2EEnv) {
				t.Helper()
				env.InitGitRepo()
				env.CreateBranch("001-test-feature")
				env.SetupConstitution()
				env.SetupAutospecInit()
				env.SetAgentPreset(testutil.AgentOpencode)
			},
			command: []string{"specify", "test feature", "--agent", "opencode"},
			verifyFunc: func(t *testing.T, env *testutil.E2EEnv, result testutil.CommandResult) {
				t.Helper()
				// Check that the mock was invoked (we verify via spec existence)
				// The call log verification happens through spec generation
				require.True(t, env.SpecExists("001-test-feature"),
					"mock-opencode.sh should have been invoked to create spec")
			},
		},
		"MOCK_EXIT_CODE is respected by mock-opencode.sh": {
			description: "Verify mock-opencode.sh returns configured exit code",
			setupFunc: func(t *testing.T, env *testutil.E2EEnv) {
				t.Helper()
				env.InitGitRepo()
				env.CreateBranch("001-test-feature")
				env.SetupConstitution()
				env.SetupAutospecInit()
				env.SetAgentPreset(testutil.AgentOpencode)
			},
			command:         []string{"specify", "test feature", "--agent", "opencode"},
			mockExitCode:    1,
			setMockExitCode: true,
			verifyFunc: func(t *testing.T, env *testutil.E2EEnv, result testutil.CommandResult) {
				t.Helper()
				// When mock returns exit code 1, autospec should fail
				require.NotEqual(t, 0, result.ExitCode,
					"autospec should propagate mock exit code failure")
			},
		},
		"OpenCode workflow generates valid spec.yaml artifact": {
			description: "Verify spec.yaml generated by OpenCode mock is valid",
			setupFunc: func(t *testing.T, env *testutil.E2EEnv) {
				t.Helper()
				env.InitGitRepo()
				env.CreateBranch("001-test-feature")
				env.SetupConstitution()
				env.SetupAutospecInit()
				env.SetAgentPreset(testutil.AgentOpencode)
			},
			command: []string{"specify", "test feature", "--agent", "opencode"},
			verifyFunc: func(t *testing.T, env *testutil.E2EEnv, result testutil.CommandResult) {
				t.Helper()
				specPath := filepath.Join(env.SpecsDir(), "001-test-feature", "spec.yaml")
				require.FileExists(t, specPath, "spec.yaml should exist")

				// Read and verify it's valid YAML with expected content
				content, err := os.ReadFile(specPath)
				require.NoError(t, err, "should be able to read spec.yaml")
				require.Contains(t, string(content), "feature:",
					"spec.yaml should have feature section")
				require.Contains(t, string(content), "user_stories:",
					"spec.yaml should have user_stories section")
				require.Contains(t, string(content), "requirements:",
					"spec.yaml should have requirements section")
			},
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			env := testutil.NewE2EEnvWithAgent(t, testutil.AgentOpencode)

			if tt.setupFunc != nil {
				tt.setupFunc(t, env)
			}

			if tt.setMockExitCode {
				env.SetMockExitCode(tt.mockExitCode)
			}

			result := env.Run(tt.command...)

			if tt.verifyFunc != nil {
				tt.verifyFunc(t, env, result)
			}
		})
	}
}

// TestE2E_OpenCodeAgentPresetSwitch verifies switching between agent presets
// works correctly in E2E tests.
func TestE2E_OpenCodeAgentPresetSwitch(t *testing.T) {
	tests := map[string]struct {
		description   string
		initialPreset testutil.AgentPreset
		switchTo      testutil.AgentPreset
		verifyFunc    func(t *testing.T, env *testutil.E2EEnv)
	}{
		"switch from claude to opencode": {
			description:   "Verify switching from Claude to OpenCode preset works",
			initialPreset: testutil.AgentClaude,
			switchTo:      testutil.AgentOpencode,
			verifyFunc: func(t *testing.T, env *testutil.E2EEnv) {
				t.Helper()
				require.Equal(t, testutil.AgentOpencode, env.AgentPreset(),
					"agent preset should be opencode after switch")

				// Verify mock opencode binary exists
				binDir := env.BinDir()
				opencodePath := filepath.Join(binDir, "opencode")
				require.FileExists(t, opencodePath, "mock opencode binary should exist")
			},
		},
		"switch from opencode to claude": {
			description:   "Verify switching from OpenCode to Claude preset works",
			initialPreset: testutil.AgentOpencode,
			switchTo:      testutil.AgentClaude,
			verifyFunc: func(t *testing.T, env *testutil.E2EEnv) {
				t.Helper()
				require.Equal(t, testutil.AgentClaude, env.AgentPreset(),
					"agent preset should be claude after switch")

				// Verify mock claude binary exists
				binDir := env.BinDir()
				claudePath := filepath.Join(binDir, "claude")
				require.FileExists(t, claudePath, "mock claude binary should exist")
			},
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			var env *testutil.E2EEnv
			if tt.initialPreset == testutil.AgentOpencode {
				env = testutil.NewE2EEnvWithAgent(t, testutil.AgentOpencode)
			} else {
				env = testutil.NewE2EEnv(t)
			}

			// Switch preset
			env.SetAgentPreset(tt.switchTo)

			if tt.verifyFunc != nil {
				tt.verifyFunc(t, env)
			}
		})
	}
}

// TestE2E_OpenCodeMockBinaryContent verifies the mock-opencode.sh script
// is properly installed and contains expected mock behavior.
func TestE2E_OpenCodeMockBinaryContent(t *testing.T) {
	tests := map[string]struct {
		description   string
		contentCheck  string
		expectedMatch bool
	}{
		"mock script has shebang": {
			description:   "Verify mock-opencode.sh starts with bash shebang",
			contentCheck:  "#!/bin/bash",
			expectedMatch: true,
		},
		"mock script identifies as mock": {
			description:   "Verify mock-opencode.sh contains 'mock' identifier",
			contentCheck:  "mock",
			expectedMatch: true,
		},
		"mock script supports MOCK_EXIT_CODE": {
			description:   "Verify mock-opencode.sh supports MOCK_EXIT_CODE env var",
			contentCheck:  "MOCK_EXIT_CODE",
			expectedMatch: true,
		},
		"mock script supports MOCK_CALL_LOG": {
			description:   "Verify mock-opencode.sh supports MOCK_CALL_LOG env var",
			contentCheck:  "MOCK_CALL_LOG",
			expectedMatch: true,
		},
		"mock script supports artifact generation": {
			description:   "Verify mock-opencode.sh supports MOCK_ARTIFACT_DIR env var",
			contentCheck:  "MOCK_ARTIFACT_DIR",
			expectedMatch: true,
		},
		"mock script supports spec generation": {
			description:   "Verify mock-opencode.sh can generate spec.yaml",
			contentCheck:  "/autospec.specify",
			expectedMatch: true,
		},
		"mock script supports plan generation": {
			description:   "Verify mock-opencode.sh can generate plan.yaml",
			contentCheck:  "/autospec.plan",
			expectedMatch: true,
		},
		"mock script supports tasks generation": {
			description:   "Verify mock-opencode.sh can generate tasks.yaml",
			contentCheck:  "/autospec.tasks",
			expectedMatch: true,
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			env := testutil.NewE2EEnvWithAgent(t, testutil.AgentOpencode)
			binDir := env.BinDir()
			opencodePath := filepath.Join(binDir, "opencode")

			content, err := os.ReadFile(opencodePath)
			require.NoError(t, err, "should be able to read mock opencode binary")

			contentStr := string(content)
			if tt.expectedMatch {
				require.True(t, strings.Contains(contentStr, tt.contentCheck),
					"mock-opencode.sh should contain %q", tt.contentCheck)
			} else {
				require.False(t, strings.Contains(contentStr, tt.contentCheck),
					"mock-opencode.sh should not contain %q", tt.contentCheck)
			}
		})
	}
}

// TestE2E_OpenCodeSlashCommands verifies mock-opencode.sh supports all
// required slash commands for artifact generation.
func TestE2E_OpenCodeSlashCommands(t *testing.T) {
	tests := map[string]struct {
		description    string
		slashCommand   string
		artifactPath   string
		artifactExists func(env *testutil.E2EEnv) bool
	}{
		"clarify slash command support": {
			description:  "Verify /autospec.clarify is supported",
			slashCommand: "/autospec.clarify",
			artifactPath: "spec.yaml", // clarify updates existing spec
			artifactExists: func(env *testutil.E2EEnv) bool {
				return env.SpecExists("001-test-feature")
			},
		},
		"checklist slash command support": {
			description:  "Verify /autospec.checklist is supported",
			slashCommand: "/autospec.checklist",
			artifactPath: "checklists/checklist.yaml",
			artifactExists: func(env *testutil.E2EEnv) bool {
				path := filepath.Join(env.SpecsDir(), "001-test-feature", "checklists", "checklist.yaml")
				_, err := os.Stat(path)
				return err == nil
			},
		},
		"analyze slash command support": {
			description:  "Verify /autospec.analyze is supported",
			slashCommand: "/autospec.analyze",
			artifactPath: "analysis.yaml",
			artifactExists: func(env *testutil.E2EEnv) bool {
				path := filepath.Join(env.SpecsDir(), "001-test-feature", "analysis.yaml")
				_, err := os.Stat(path)
				return err == nil
			},
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			env := testutil.NewE2EEnvWithAgent(t, testutil.AgentOpencode)
			binDir := env.BinDir()
			opencodePath := filepath.Join(binDir, "opencode")

			// Verify the mock script contains support for this slash command
			content, err := os.ReadFile(opencodePath)
			require.NoError(t, err, "should be able to read mock opencode binary")

			contentStr := string(content)
			require.True(t, strings.Contains(contentStr, tt.slashCommand),
				"mock-opencode.sh should support %s", tt.slashCommand)
		})
	}
}

// TestE2E_OpenCodeEnvironmentIsolation verifies the OpenCode agent runs
// in properly isolated E2E environment without API key leakage.
func TestE2E_OpenCodeEnvironmentIsolation(t *testing.T) {
	tests := map[string]struct {
		description string
		verifyFunc  func(t *testing.T, env *testutil.E2EEnv)
	}{
		"no API keys with OpenCode agent": {
			description: "Verify no API keys leak into OpenCode agent environment",
			verifyFunc: func(t *testing.T, env *testutil.E2EEnv) {
				t.Helper()
				env.AssertNoAPIKeys(t)
			},
		},
		"PATH isolation with OpenCode agent": {
			description: "Verify PATH is properly isolated for OpenCode agent",
			verifyFunc: func(t *testing.T, env *testutil.E2EEnv) {
				t.Helper()
				env.AssertMockOnlyPath(t)
			},
		},
		"temp state dir with OpenCode agent": {
			description: "Verify state files use temp dir with OpenCode agent",
			verifyFunc: func(t *testing.T, env *testutil.E2EEnv) {
				t.Helper()
				env.AssertTempStateDir(t)
			},
		},
		"both mock binaries available": {
			description: "Verify both claude and opencode mocks are available",
			verifyFunc: func(t *testing.T, env *testutil.E2EEnv) {
				t.Helper()
				binDir := env.BinDir()

				claudePath := filepath.Join(binDir, "claude")
				opencodePath := filepath.Join(binDir, "opencode")

				require.FileExists(t, claudePath, "mock claude should exist")
				require.FileExists(t, opencodePath, "mock opencode should exist")
			},
		},
	}

	for name, tt := range tests {
		t.Run(name, func(t *testing.T) {
			env := testutil.NewE2EEnvWithAgent(t, testutil.AgentOpencode)
			tt.verifyFunc(t, env)
		})
	}
}
